I"7<blockquote>
  <p>Apple 에서 공개한 <a href="https://docs.swift.org/swift-book/">The Swift Programming Language (Swift 5.2)</a> 책의 <a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html">Generics</a> 부분<sup id="fnref:Generics" role="doc-noteref"><a href="#fn:Generics" class="footnote">1</a></sup>을 번역하고 정리한 글입니다.</p>

  <p>현재 전체 중에서 번역 완료된 목록은 <a href="http://xho95.github.io/swift/programming/language/grammar/2017/02/27/The-Swift-Programming-Language.html">Swift 5.2: Swift Programming Language (스위프트 프로그래밍 언어)</a> 에서 확인할 수 있습니다.</p>
</blockquote>

<h2 id="generics">Generics</h2>

<h3 id="generic-where-clauses-일반화된-where-구절">Generic Where Clauses (일반화된 where 구절)</h3>

<p><a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID186">Type Constraints (타입 구속 조건)</a> 에서 설명한 대로, ‘타입 구속 조건’을 사용하면 일반화된 함수, 일반화된 첨자 연산자 또는 일반화된 타입들과 관련된 타입 매개 변수들의 요구 사항을 정의 할 수 있습니다.</p>

<p>여기에 더해서 ‘관련 타입 (associated type)’ 에 대한 요구 사항을 정의할 때도 유용하게 쓸 수 있는데, 이 때는 <em>일반화된 where 구절</em> 을 정의하면 됩니다. 일반화된 <code class="highlighter-rouge">where</code> 구절을 사용하면 ‘관련 타입’이 반드시 특정 프로토콜을 준수해야 한다거나, 특정 ‘타입 매개 변수’와 ‘관련 타입’이 같아야 한다는 요구 사항들을 덧붙일 수 있습니다. 일반화된 <code class="highlighter-rouge">where</code> 구절은 <code class="highlighter-rouge">where</code> 키워드로 시작해서, 뒤이어서 ‘관련 타입’ 에 대한 ‘구속 조건’ 또는 타입과 ‘관련 타입’ 간의 ‘동등 관계’ 등이 따라옵니다. 일반화된 <code class="highlighter-rouge">where</code> 구절은 타입이나 함수 본문의 시작 괄호 바로 앞에 작성합니다.</p>

<p>아래 예제는 일반화된 함수인 <code class="highlighter-rouge">allItemsMatch</code> 를 정의하는데, 이 함수는 두 개의 <code class="highlighter-rouge">Container</code> 인스턴스가 동일한 요소를 동일한 순서로 갖고 있는지를 검사합니다. 이 함수는 불 (Boolean) 값을 반환하며 모든 요소가 일치하면 <code class="highlighter-rouge">true</code> 를 그렇지 않으면 <code class="highlighter-rouge">false</code> 를 반환합니다.</p>

<p>두 컨테이너를 검사할 때 컨테이너의 타입이 같을 필요는 없지만 (물론 같더라도 상관없습니다), 각 요소들의 타입은 같아야 합니다. 이 요구 사항은 ‘타입 구속 조건 (type constraints)’ 과 ‘일반화된 where 구절’ 을 조합하여 표현합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">allItemsMatch</span><span class="o">&lt;</span><span class="kt">C1</span><span class="p">:</span> <span class="kt">Container</span><span class="p">,</span> <span class="kt">C2</span><span class="p">:</span> <span class="kt">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">someContainer</span><span class="p">:</span> <span class="kt">C1</span><span class="p">,</span> <span class="n">_</span> <span class="nv">anotherContainer</span><span class="p">:</span> <span class="kt">C2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="k">where</span> <span class="kt">C1</span><span class="o">.</span><span class="kt">Item</span> <span class="o">==</span> <span class="kt">C2</span><span class="o">.</span><span class="kt">Item</span><span class="p">,</span> <span class="kt">C1</span><span class="o">.</span><span class="kt">Item</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="c1">// Check that both containers contain the same number of items.</span>
  <span class="k">if</span> <span class="n">someContainer</span><span class="o">.</span><span class="n">count</span> <span class="o">!=</span> <span class="n">anotherContainer</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>

  <span class="c1">// Check each pair of items to see if they're equivalent.</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">someContainer</span><span class="o">.</span><span class="n">count</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">someContainer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">anotherContainer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// All items match, so return true.</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 함수는 두 인자로 <code class="highlighter-rouge">someContainer</code> 와 <code class="highlighter-rouge">anotherContainer</code> 를 사용합니다. <code class="highlighter-rouge">someContainer</code> 인자는 <code class="highlighter-rouge">C1</code> 타입이고, <code class="highlighter-rouge">anotherContainer</code> 인자는 <code class="highlighter-rouge">C2</code> 타입입니다. <code class="highlighter-rouge">C1</code> 과 <code class="highlighter-rouge">C2</code> 는 두 개의 컨테이터 타입을 위한 ‘타입 매개 변수’ 로써 함수가 호출될 때 결정됩니다.</p>

<p>이 함수의 두 ‘타입 매개 변수’는 아래의 요구 사항들을 갖습니다:</p>

<ul>
  <li><code class="highlighter-rouge">C1</code> 은 반드시 <code class="highlighter-rouge">Container</code> 프로토콜을 준수해야 합니다. (<code class="highlighter-rouge">C1: Container</code> 로 적혀 있습니다.)</li>
  <li><code class="highlighter-rouge">C2</code> 도 반드시 <code class="highlighter-rouge">Container</code> 프로토콜을 준수해야 합니다. (<code class="highlighter-rouge">C2: Container</code> 로 적혀 있습니다.)</li>
  <li><code class="highlighter-rouge">C1</code> 의 요소는 <code class="highlighter-rouge">C2</code> 의 요소와 반드시 동일해야 합니다. (<code class="highlighter-rouge">C1.Item == C2.Item</code> 로 적혀 있습니다.)<sup id="fnref:Items" role="doc-noteref"><a href="#fn:Items" class="footnote">2</a></sup></li>
  <li><code class="highlighter-rouge">C1</code> 의 요소는 반드시 <code class="highlighter-rouge">Equatable</code> 프로토콜을 준수해야 합니다. (<code class="highlighter-rouge">C1.Item : Equatable</code> 로 적혀 있습니다.)</li>
</ul>

<p>첫 번째와 두 번째 요구 사항은 함수의 유형 ‘매개 변수 목록 (type parameter list)’ 에 정의되어 있고, 세 번째와 네 번째 요구 사항은 ‘일반화된 where 구절’ 에 정의되어 있습니다.</p>

<p>이 요구 사항들이 의미하는 것은 다음과 같습니다:</p>

<ul>
  <li><code class="highlighter-rouge">someContainer</code> 는 <code class="highlighter-rouge">C1</code> 타입의 컨테이너 입니다.</li>
  <li><code class="highlighter-rouge">anotherContainer</code> 는 <code class="highlighter-rouge">C2</code> 타입의 컨테이너 입니다.</li>
  <li><code class="highlighter-rouge">someContainer</code> 와 <code class="highlighter-rouge">anotherContainer</code> 는 같은 타입의 요소를 가집니다.</li>
  <li><code class="highlighter-rouge">someContainer</code> 의 요소들은 ‘같지 않음 연산자 (!=)’ 로 서로 다른지를 확인할 수 있어야 합니다.</li>
</ul>

<p>세 번째와 네 번째 요구 사항을 조합하면 <code class="highlighter-rouge">anotherContainer</code> 의 요소들도 ‘같지 않음 연산자 (!=)’ 로 검사할 수 있다는 의미가 되는데, 이는 <code class="highlighter-rouge">someContainer</code> 의 요소와 타입이 똑 같기 때문입니다.</p>

<p>이러한 요구 사항에 덕분에 두 컨테이너의 타입이 달라도 <code class="highlighter-rouge">allItemsMatch(_:_:)</code> 함수로 비교할 수 있게 되는 것입니다.</p>

<p><code class="highlighter-rouge">allItemsMatch(_:_:)</code> 함수는 먼저 두 컨테이너의 요소 개수가 같은지를 검사합니다. 요소의 개수가 다르다면, 서로 같을 수가 없으므로, 함수의 반환 값은 <code class="highlighter-rouge">false</code> 입니다.</p>

<p>이 검사를 마친 후, <code class="highlighter-rouge">someContainer</code> 의 모든 요소들에 반복해서 적용할 방법으로 <code class="highlighter-rouge">for-in</code> 루프와 ‘반-개방 범위 연산자 (<code class="highlighter-rouge">..&lt;</code>)’를 사용합니다. 각 요소 마다, <code class="highlighter-rouge">someContainer</code> 의 요소와 <code class="highlighter-rouge">anotherContainer</code> 의 요소가 다른지를 검사합니다. 두 요소가 다르다면, 두 컨테이너가 같을 수 없으므로, 함수의 반환 값은 <code class="highlighter-rouge">false</code> 입니다.</p>

<p>아무런 문제없이 루프를 완료하면, 두 컨테이너가 같은 것이므로, 함수의 반환 값은 <code class="highlighter-rouge">true</code> 입니다.</p>

<p><code class="highlighter-rouge">allItemsMatch(_:_:)</code> 함수의 사용법은 다음과 같습니다:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">stackOfStrings</span> <span class="o">=</span> <span class="kt">Stack</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">()</span>
<span class="n">stackOfStrings</span><span class="o">.</span><span class="nf">push</span><span class="p">(</span><span class="s">"uno"</span><span class="p">)</span>
<span class="n">stackOfStrings</span><span class="o">.</span><span class="nf">push</span><span class="p">(</span><span class="s">"dos"</span><span class="p">)</span>
<span class="n">stackOfStrings</span><span class="o">.</span><span class="nf">push</span><span class="p">(</span><span class="s">"tres"</span><span class="p">)</span>

<span class="k">var</span> <span class="nv">arrayOfStrings</span> <span class="o">=</span> <span class="p">[</span><span class="s">"uno"</span><span class="p">,</span> <span class="s">"dos"</span><span class="p">,</span> <span class="s">"tres"</span><span class="p">]</span>

<span class="k">if</span> <span class="nf">allItemsMatch</span><span class="p">(</span><span class="n">stackOfStrings</span><span class="p">,</span> <span class="n">arrayOfStrings</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"All items match."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Not all items match."</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Prints "All items match."</span>
</code></pre></div></div>

<p>The example also creates an Array instance initialized with an array literal containing the same three strings as the stack. Even though the stack and the array are of a different type, they both conform to the Container protocol, and both contain the same type of values. You can therefore call the allItemsMatch(<em>:</em>:) function with these two containers as its arguments. In the example above, the allItemsMatch(<em>:</em>:) function correctly reports that all of the items in the two containers match.</p>

<p>위 예제는 <code class="highlighter-rouge">String</code> (문자열) 값을 저장하기 위해 <code class="highlighter-rouge">Stack</code> (스택) 인스턴스를 만들고, 3 개의 문자열을 스택에 집어 넣습니다. 또 <code class="highlighter-rouge">Array</code> (배열) 인스턴스를 만든 다음 ‘배열 문자식 (array literal)’ 으로 초기화할 때 스택에 넣었던 것과 동일한 3 개의 문자열을 사용합니다. 스택과 배열은 다른 타입이지만, 둘 다 <code class="highlighter-rouge">Container</code> 프로토콜을 준수하며, 같은 타입의 값을 갖고 있습니다. 따라서 <code class="highlighter-rouge">allItemsMatch(_:_:)</code> 함수를 호출하면서 이 두 컨테이너를 인자로 넣을 수 있습니다. 위에서 <code class="highlighter-rouge">allItemsMatch(_:_:)</code> 함수가 두 컨테이터의 모든 요소 값들을 제대로 비교하고 있음을 확인할 수 있습니다.</p>

<h3 id="생각거리">생각거리</h3>

<h3 id="참고-자료">참고 자료</h3>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:Generics" role="doc-endnote">
      <p>원문은 <a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html">Generics</a>에서 확인할 수 있습니다. <a href="#fnref:Generics" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:Items" role="doc-endnote">
      <p>이 조건을 만족하면 요소의 값뿐만 아니라, 각 요소들의 타입이 같다는 것도 보장됩니다. 각 요소가 같음을 비교하려면 각 요소의 타입이 같아야 하기 때문입니다. <a href="#fnref:Items" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET