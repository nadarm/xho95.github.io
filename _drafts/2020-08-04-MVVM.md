---
layout: post
comments: true
title:  "Swift: MVVM 알아보기"
date:   2020-08-04 19:45:00 +0900
categories: Swift Architecture Logic MVVM
---

> 이 글은 SwiftUI 에서 사용하는 MVVM 패턴을 이해하기 위해 위키피디아의 [Model–view–viewmodel](https://en.wikipedia.org/wiki/Model–view–viewmodel) 과 [모델-뷰-뷰모델](https://ko.wikipedia.org/wiki/모델-뷰-뷰모델) 항목을 참고하여 정리한 글입니다.
>
> 위키피디아에 있는 항목의 한글 번역 및 기존 번역 수정을 제가 했기 때문에, 일부 내용은 위키피디아의 내용과 동일할 수 있습니다.

## Swift: MVVM 알아보기

이 글을 작성하게 된 계기는, 스탠포드 대학교의 [SwiftUI 강의 (cs193p)](https://cs193p.sites.stanford.edu) 를 보다가, 아래 그림과 같이 MVVM, 에서는 '로직 (Logic)' 이 '모델 (Model)' 에 위치한다는 것을 알게 됨으로 인해 비롯된 것입니다. MVC 패턴을 사용할 때는 보통 '비지니스 로직 (business logic)' 을 '컨트롤러 (Controller)' 에 두었는데, MVVM 에서는 '모델' 에 '로직' 을 두는 것을 보고 그 이유를 알아보기 위해 작성하게 정리를 해봐야 겠다고 생각하게 되었습니다.

![MVVM](/assets/Swift/Pattern/MVVM-cs193p-2020.png)
<이미지 출처: [Stanford lecture - cs193p](https://cs193p.sites.stanford.edu)>

MVVM 관련 자료를 찾아보니, '로직' 의 위치에 대해 저마다 서로 다른 의견을 제시하고 있었는데, 위키피디아의 MVVM 항목이 가장 잘 설명하고 있다고 느껴서 해당 항목을 기준으로 내용을 정리하게 되었습니다.

> 이 글은 위키피디아의 MVVM 문서를 한글로 번역하면서 같이 작성한 것이기 때문에, 두 문단 정도는 내용이 위키피디아와 동일할 수 있습니다.

### Model-View-ViewModel (모델-뷰-뷰 모델)

**모델-뷰-뷰 모델 (model-view-viewmodel; MVVM)** 은 하나의 소프트웨어 아키텍쳐 패턴으로 - 마크 업 언어 또는 GUI 코드로 구현하는 - 그래픽 사용자 인터페이스 (_뷰_) 의 개발을 비지니스 로직 또는 백-엔드 로직 (_모델_) 으로 부터 분리 시켜서 뷰가 어떤 특정한 모델 플랫폼에 종속되지 않도록 합니다. MVVM 의 _뷰 모델_ 은 값 변환기인데,[1] 이는 뷰 모델이 모델에 있는 데이터 객체를 노출 (변환) 하는 책임을 짐으로써 객체의 관리과 표현이 수월해진다는 것을 의미합니다. 이러한 점에서, 뷰 모델은 뷰 보다는 더 모델인 것이며, 모든 뷰의 디스플레이 로직을 제외한 대부분의 것들을 처리합니다.[1] 뷰 모델은 뷰에 의해 지원되는 일련의 사용 사례에 대한 백엔드 로직에 대한 액세스를 구성하는 중개자 패턴을 구현할 수있다.

뷰 모델은, 백-엔드 로직에 대한 접근 주위로 뷰에서 지원하는 유즈 케이스 집합이 구성되도록, 중재자 패턴으로 구현할 수도 있습니다.

![MVVM](https://en.wikipedia.org/wiki/File:MVVMPattern.png)
![MVVM](/assets/Swift/Pattern/MVVM-wikipedia.png)
<이미지 출처: [Wikipedia](https://en.wikipedia.org/wiki/Model–view–viewmodel)>

MVVM 은 '마틴 파울러 (Martin Fowler)' 의 '프레젠테이션 모델 디자인 패턴' 의 변형에 해당합니다.[2] [3] 이는 사용자 인터페이스의 '이벤트-기반 프로그래밍 (event-driven programming)' 을 단순화하기 위해 마이크로소프트의 아키텍트인 '켄 쿠퍼 (Ken Cooper)' 와 '테드 피터스 (Ted Peters)' 에 의해 발명되었습니다. 이 패턴은 (마이크로소프트의 닷넷 그래픽 시스템인) '윈도우즈 프리젠테이션 파운데이션 (WPF)' 및 (WPF 의 인터넷 응용 프로그램 파생품인) '실버라이트' 에 통합되었습니다.[3] 마이크로소프트의 WPF 와 실버라이트 아키텍트인, '존 구스먼 (John Gossman)' 은, 2005년 자신의 블로그에 MVVM 을 발표하였습니다.[3]

모델-뷰-뷰모델은 **모델-뷰-바인더 (model-view-binder)** 라고도 하는데, 특히 구현이 닷넷 플랫폼과 관련없을 때 그렇게 부릅니다. (자바로 작성된 웹 응용 프로그램 프레임웍인) ZK 와 (자바스크립트 라이브러리인) KnockoutJS 는 모델-뷰-바인더를 사용합니다.[3] [4] [5]

### Components of MVVM Pattern (MVVM 패턴의 구성 성분)

#### Model (모델)

_모델_ 은 실제 상태 내용을 표현하는, 도메인 모델을 참조하거나 (이를 객체-지향 접근법이라 합니다), 또는 내용을 표현하는, 데이터 접근 계층을 참조합니다. (이를 데이터-중심 접근법이라 합니다).

#### View (뷰)

모델-뷰-컨트롤러 (model-view-controller; MVC) 와 모델-뷰-발표자 (model-view-presenter; MVP) 패턴에서와 같이, _뷰_ 는 사용자가 화면에서 보는 것들에 대한 구조, 배치, 그리고 외관에 해당합니다.[6] 모델을 보여서 표현하고 사용자와 뷰의 상호 작용 (클릭, 키보드, 동작, 등) 을 수신하여, 이에 대한 처리를 뷰와 뷰 모델의 연결을 정의하고 있는 (속성, 이벤트 콜백 함수, 등의) 데이터 바인딩 (data binding; 데이터 연결) 을 통하여 뷰 모델로 전달합니다.

#### View Model (뷰 모델)

_뷰 모델_ 은 공용 속성과 공용 명령을 노출하는 뷰에 대한 '추상화 (abstraction)' 입니다. MVC 패턴의 '컨트롤러' 나, MVP 패턴의 '발표자 (presenter)' 를 대신하여, MVVM 은 _바인더 (binder; 연결자)_ 를 가지고 있는데, 이는 뷰와 뷰 모델에 있는 뷰에 연결된 속성 간의 통신을 자동화 합니다. 뷰 모델은 모델 안에 있는 데이터의 상태라고 설명하기도 합니다.[7]

뷰 모델과 MVP 패턴에 있는 발표자 사이의 주요 차이점은 발표자는 뷰에 대한 참조를 가지고 있는 반면, 뷰 모델은 그렇지 않다는 것입니다. 그 대신, 뷰는 뷰 모델의 속성에 직접 연결되어 있는 채로 업데이트를 주고 받습니다. 효율적으로 작동하려면, '바인딩 기술 (binding technology; 연결 기술)' 또는 '바인딩' 을 하기 위한 상용구 코드를 생성하는 것이 필수입니다.[6]

### Binder (바인더; 연결자)

선언적인 데이터와 '명령-바인딩 (명령-연결)' 은 MVVM 패턴에서는 내재된 것입니다. 마이크로소프트 솔루현 스택에서, 바인더는 XAML 이라는 마크 업 언어입니다.[8] 바인더는 뷰 모델과 뷰를 동기화하는 상용구 로직을 반복해서 작성해야 하는 의무에서 개발자를 해방시켜 줍니다. 마이크로소프트 스택의 외부에서 구현할 때, '선언적인 데이터 바인딩 기술' 이 있다면 이 패턴이 가능하겠지만,[4] [9] 바인더가 없다면, 그 대신 일반적인 MVP 나 MVC 를 사용하게 될 것이고 더 많은 상용구 코드를 작성 (아니면 이를 다른 도구를 써서 생성) 해야 할 것입니다.[^microsoft]

### Rationale (근거)

MVVM 은 WPF (윈도우즈 프리젠테이션 파운데이션) 의 데이터 바인딩 기능을 사용하여, 뷰 계층에서 사실상 모든 GUI 코드를 제거하여, 패턴의 나머지 부분에서 뷰 계층의 개발을 더 용이하게 분리할 수 있도록 설계되었습니다.[3] 사용자 경험 (UX) 개발자가 GUI 코드를 필수로 작성하도록 하는 대신, 프레임웍의 마크 업 언어 (가령, XAML) 를 사용해서, 응용 프로그램 개발자가 작성하고 관리하는, 뷰 모델에 대한 데이터 바인딩을 생성할 수 있습니다. 역할의 분리는 상호 작용 설계자가 비지니스 로직을 프로그래밍하기 보다 UX 의 요구에 집중하도록 해줍니다. 그로 인해 응용 프로그램의 계층 별로 작업 흐름을 다-분화하여 생산성을 높일 수 있습니다. 설령 단일 개발자가 전체 코드 기초를 개발하는 경우에도, 모델에서 뷰를 적절히 분리하는 것이 더 생산적인데, 사용자 인터페이스는 일반적으로 최종-사용자의 피드백을 기반으로 하여 개발 주기 과정에서 자주 그리고 뒤늦게 바뀌기 때문입니다.

MVVM 패턴은, 데이터를 가능한 순수한 응용 프로그램 모델에 가깝게 바인딩 (연결) 하는 데이터 바인딩과 프레임웍의 장점을 활용함과 동시에, MVC 가 제공하는 기능 요소 개발의 분리라는 장점까지 해서, 이 둘을 다 획득하려고 시도합니다.[3] [10] [11] 이는 바인더 (연결자), 뷰 모델, 그리고 어떤 비즈니스 계층에 있는 데이터-검사 기능을 사용하여 들어오는 데이터를 검증합니다. 결과적으로 모델과 프레임웍은 가능한 많은 작업을 수행하며, 뷰를 직접 조작하는 응용 프로그램 로직을 최소화하거나 없애버립니다.

### Criticism (비판)

이 패턴에 대한 비판은 MVVM 제작자인 존 구스만 (John Gossman) 자신이 한 것인데,[12] 단순한 UI 작업에서는 MVVM 을 구현하는 부담이 "지나치게 과하다" 고 지적합니다. 그가 말하길 응용 프로그램이 점점 더 커짐에 따라서, 뷰 모델을 폭 넓게 사용하기가 점점 더 어려워진다고 합니다. 게다가, 아주 큰 응용 프로그램에서 데이터 바인딩을 사용하게 되면 눈에 띄게 메모리를 소모하게 된다고 설명합니다.

### 참고 자료

[^microsoft]: MVVM 패턴이라는 것이 마이크로소프트에서 개발된 것일 수는 있지만, 앞서 설명에서도 하고 있지만 MVVM 자체가 MVP 에서 나오게 된 개념인데, 뭔가 이부분의 설명만을 보면 위키피디아의 MVVM 항목을 마이크로소프트 직원이 작성한 것이 아닌가 하는 생각이 들 정도입니다. 여튼 MVVM 을 소개하면서 MVC, MVP 를 비판하고 있는 부분이 좀 재밌습니다.
