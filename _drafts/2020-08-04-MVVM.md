---
layout: post
comments: true
title:  "SwiftUI 에서 사용하는 MVVM 알아보기"
date:   2020-08-04 19:45:00 +0900
categories: Swift Architecture Logic MVVM
---

> 이 글은 SwiftUI 에서 사용하는 MVVM 패턴을 이해하기 위해 위키피디아의 [Model–view–viewmodel](https://en.wikipedia.org/wiki/Model–view–viewmodel) 과 [모델-뷰-뷰모델](https://ko.wikipedia.org/wiki/모델-뷰-뷰모델) 항목을 참고하여 정리한 글입니다.
>
> 위키피디아에 있는 항목의 한글 번역 및 기존 번역 수정을 제가 했기 때문에, 일부 내용은 위키피디아의 내용과 동일할 수 있습니다.

## SwiftUI 에서 사용하는 MVVM 알아보기

이 글을 작성하게 된 계기는, 스탠포드 대학교의 SwiftUI 강의 (cs193p) 를 보다가, 아래와 같이 MVVM 에서는 '로직 (Logic)' 이 '모델 (Model)' 에 위치하는 것을 알게 되면서 였습니다. MVC 패턴을 사용할 때는 보통 '비지니스 로직 (business logic)' 을 '컨트롤러 (Controller)' 에 뒀었는데, MVVM 에서는 '모델' 에 '로직' 을 두는 것을 보고 정리를 해봐야 겠다고 생각하게 되었습니다.

![MVVM](/assets/Swift/Pattern/MVVM-cs193p-2020.png)
<이미지 출처: [Stanford lecture - cs193p](https://cs193p.sites.stanford.edu)>

MVVM 관련 자료를 찾아보니, '로직' 의 위치에 대해 저마다 서로 다른 의견을 제시하고 있었는데, 위키피디아의 MVVM 항목이 가장 잘 설명하고 있다고 느껴서 해당 항목을 기준으로 내용을 정리하게 되었습니다.

> 이 글은 위키피디아의 MVVM 문서를 한글로 번역하면서 같이 작성한 것이기 때문에, 두 문단 정도는 내용이 위키피디아와 동일할 수 있습니다.

### Model-View-ViewModel (모델-뷰-뷰 모델)

**모델-뷰-뷰 모델 (model-view-viewmodel; MVVM)** 은 하나의 소프트웨어 아키텍쳐 패턴으로 - 마크 업 언어 또는 GUI 코드로 구현하는 - 그래픽 사용자 인터페이스 (_뷰_) 의 개발을 비지니스 로직 또는 백-엔드 로직 (_모델_) 으로 부터 분리 시켜서 뷰가 어떤 특정한 모델 플랫폼에 종속되지 않도록 합니다. MVVM 의 _뷰 모델_ 은 값 변환기인데,[1] 이는 뷰 모델이 모델에 있는 데이터 객체를 노출 (변환) 하는 책임을 짐으로써 객체의 관리과 표현이 수월해진다는 것을 의미합니다. 이러한 점에서, 뷰 모델은 뷰 보다는 더 모델인 것이며, 모든 뷰의 디스플레이 로직을 제외한 대부분의 것들을 처리합니다.[1] 뷰 모델은 뷰에 의해 지원되는 일련의 사용 사례에 대한 백엔드 로직에 대한 액세스를 구성하는 중개자 패턴을 구현할 수있다.

뷰 모델은, 백-엔드 로직에 대한 접근 주위로 뷰에서 지원하는 유즈 케이스 집합이 구성되도록, 중재자 패턴으로 구현할 수도 있습니다.

![MVVM](/assets/Swift/Pattern/MVVM-wikipedia.png)
<이미지 출처: [Wikipedia](https://en.wikipedia.org/wiki/Model–view–viewmodel)>

MVVM 은 '마틴 파울러 (Martin Fowler)' 의 '프레젠테이션 모델 디자인 패턴' 의 변형에 해당합니다.[2] [3] 이는 사용자 인터페이스의 '이벤트-기반 프로그래밍 (event-driven programming)' 을 단순화하기 위해 마이크로소프트의 아키텍트인 '켄 쿠퍼 (Ken Cooper)' 와 '테드 피터스 (Ted Peters)' 에 의해 발명되었습니다. 이 패턴은 (마이크로소프트의 닷넷 그래픽 시스템인) 윈도우즈 프리젠테이션 파움데이션 (WPF) 및 (WPF 의 인터넷 응용 프로그램 파생품인) 실버라이트 에 통합되었습니다.[3] 마이크로소프트의 WPF 와 실버라이트 아키텍트인, '존 구스먼 (John Gossman)' 은, 2005년 자신의 블로그에 MVVM 을 발표하였습니다.[3]

모델-뷰-뷰모델은 **모델-뷰-바인더 (model-view-binder)** 라고도 하는데, 특히 구현이 닷넷 플랫폼과 관련없을 때 그렇게 부릅니다. (자바로 작성된 웹 응용 프로그램 프레임웍인) ZK 와 (자바스크립트 라이브러리인) KnockoutJS 는 모델-뷰-바인더를 사용합니다.[3] [4] [5]

### Components of MVVM Pattern (MVVM 패턴의 구성 성분)

#### Model (모델)

_모델_ 은 실제 상태 내용을 표현하는, 도메인 모델을 참조하거나 (이를 객체-지향 접근법이라 합니다), 또는 내용을 표현하는, 데이터 접근 계층을 참조합니다. (이를 데이터-중심 접근법이라 합니다).

#### View (뷰)

모델-뷰-컨트롤러 (model-view-controller; MVC) 와 모델-뷰-발표자 (model-view-presenter; MVP) 패턴에서와 같이, _뷰_ 는 사용자가 화면에서 보는 것들에 대한 구조, 배치, 그리고 외관에 해당합니다.[6] 모델을 보여서 표현하고 사용자와 뷰의 상호 작용 (클릭, 키보드, 동작, 등) 을 수신하여, 이에 대한 처리를 뷰와 뷰 모델의 연결을 정의하고 있는 (속성, 이벤트 콜백 함수, 등의) 데이터 바인딩 (data binding; 데이터 연결) 을 통하여 뷰 모델로 전달합니다.

#### View Model (뷰 모델)

_뷰 모델_ 은 공용 속성과 공용 명령을 노출하는 뷰에 대한 '추상화 (abstraction)' 입니다. MVC 패턴의 '컨트롤러' 나, MVP 패턴의 '발표자 (presenter)' 를 대신하여, MVVM 은 _바인더 (binder; 연결자)_ 를 가지고 있는데, 이는 뷰와 뷰 모델에 있는 뷰에 연결된 속성 간의 통신을 자동화 합니다. 뷰 모델은 모델 안에 있는 데이터의 상태라고 설명하기도 합니다.[7]

뷰 모델과 MVP 패턴에 있는 발표자 사이의 주요 차이점은 발표자는 뷰에 대한 참조를 가지고 있는 반면, 뷰 모델은 그렇지 않다는 것입니다. 그 대신, 뷰는 뷰 모델의 속성에 직접 연결되어 있는 채로 업데이트를 주고 받습니다. 효율적으로 작동하려면, '바인딩 기술 (binding technology; 연결 기술)' 또는 '바인딩 (binding; 연결)' 을 하기 위한 상용구 코드를 생성하는 것이 필수입니다.[6]

### Binder (바인더; 연결자)

선언적 데이터와 명령 바인딩은 MVVM 패턴에 내재되어 있습니다. Microsoft 솔루션 스택에서 바인더는 XAML이라는 마크 업 언어입니다. [8] 바인더는 뷰 모델과 뷰를 동기화하기 위해 개발자가 보일러 플레이트 로직을 작성하지 않아도됩니다. Microsoft 스택 외부에서 구현할 때 선언적 데이터 바인딩 기술이 존재하면 이러한 패턴을 가능하게 할 수 있습니다. [4] [9] 바인더가 없으면 일반적으로 MVP 또는 MVC를 사용하고 더 많은 상용구를 작성해야합니다 (또는 다른 도구로 생성하십시오).

### Rationale (근거)

MVVM은 WPF (Windows Presentation Foundation)의 데이터 바인딩 기능을 사용하여 뷰 레이어에서 거의 모든 GUI 코드 ( "코드 숨김")를 제거하여 나머지 패턴에서 뷰 레이어 개발을보다 쉽게 ​​분리 할 수 ​​있도록 설계되었습니다. .[삼] UX (User Experience) 개발자가 GUI 코드를 작성하도록 요구하는 대신 프레임 워크 마크 업 언어 (예 : XAML)를 사용하고 애플리케이션 개발자가 작성 및 유지 보수하는보기 모델에 대한 데이터 바인딩을 작성할 수 있습니다. 역할 분리를 통해 대화 형 설계자는 비즈니스 로직 프로그래밍보다는 UX 요구에 집중할 수 있습니다. 따라서 애플리케이션의 계층을 여러 작업 스트림으로 개발하여 생산성을 높일 수 있습니다. 단일 개발자가 전체 코드베이스에서 작업하는 경우에도 사용자 인터페이스는 일반적으로 최종 사용자 피드백을 기반으로 개발주기의 후반부에 자주 변경되므로 모델에서 뷰를 적절히 분리하는 것이 더 생산적입니다.

MVVM 패턴은 MVC가 제공하는 기능 개발 분리의 장점과 데이터를 가능한 순수한 애플리케이션 모델에 가깝게 바인딩하여 프레임 워크를 활용하면서 프레임 워크를 활용하려고합니다. [3] [10] [11] [ 설명 필요] 바인더, 뷰 모델 및 비즈니스 계층의 데이터 확인 기능을 사용하여 들어오는 데이터의 유효성을 검사합니다. 결과적으로 모델과 프레임 워크는 가능한 많은 작업을 수행하여 뷰 (예 : 코드 숨김)를 직접 조작하는 응용 프로그램 논리를 제거하거나 최소화합니다.

### Criticism (비판)

이 패턴에 대한 비판은 MVVM 제작자 인 John Gossman 자신으로부터 비롯된 것입니다. [12] MVVM을 구현하는 데 드는 오버 헤드는 단순한 UI 작업에서 "과잉"이라고 지적합니다. 그는 대규모 애플리케이션의 경우 ViewModel을 일반화하는 것이 더 어려워 진다고 말합니다. 또한 그는 매우 큰 응용 프로그램의 데이터 바인딩으로 인해 상당한 메모리 소비가 발생할 수 있다고 설명합니다.

### 참고 자료
