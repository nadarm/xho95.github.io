## API 설계 지침 (Design Guidelines)

### 목차 

* [Fundamentals](#fundamentals)
* Naming
	* Promote Clear Usage
	* Strive for Fluent Usage
	* Use Terminology Well
* Conventions
	* General Conventions
	* Parameters
	* Argument Labels
* [Special Instructions](#special-instructions)

<a name="#fundamentals"></a>
### Fundamentals

* **사용할 때 명확한 것**이 가장 중요한 목표입니다. 메소드와 속성과 같은 엔티티는 한 번만 선언되지만 계속해서 사용됩니다. 이처럼 사용할 때 분명하고 간결하게 쓸 수 있는 API를 설계하도록 합니다. 설계를 평가할 때 선언만 보는 것은 대부분의 경우 충분하지 않습니다; 항상 실제 사용 사례를 검사해서 문맥상에서 분명하게 느껴지도록 만들어야 합니다.

* **명확한 것은 간결한 것보다 더 중요합니다.** 스위프트 (Swift) 코드는 간소화할 수 있지만 가장 적은 수의 글자로 가능한 가장 작은 코드를 만드는 것이 목표는 아닙니다. 스위프트 코드의 간결함은 강한 타입 시스템의 부수 효과이며 자연스럽게 뻔한 코드를 줄이는 특징을 가집니다. (좀 더 매끄럽게 고칩니다.)

* **문서 주석달기**를 모든 선언에 하도록 합니다. 문서를 작성하면서 얻게되는 통찰력은 설계할 때 중요한 영향을 미칠 수 있으므로 이를 미루지 않도록 합니다.

	> API 의 기능을 간단한 말로 설명하기 어렵다면 이는 **잘못된 API 를 설계하고 있는 것**일 수 있습니다.

	* 스위프트의 [자체 마크다운 (dialect of Markdown)](https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/) 을 사용합니다.

	* **요약으로 시작**해서 선언되는 엔티티들을 설명하는 것이 첫번째입니다. 때때로 API 는 선언과 요약만으로 완전히 이해할 수도 있습니다.

		```swift
		/// Returns a "view" of `self` containing the same elements in
		/// reverse order.
		func reversed() -> ReverseCollection
		```
		
		* Focus on the summary; it’s the most important part. Many excellent documentation comments consist of nothing more than a great summary.
		
		* Use a single sentence fragment if possible, ending with a period. Do not use a complete sentence.
		
		* Describe what a function or method does and what it returns, omitting null effects and Void returns:

			```
			/// Inserts `newHead` at the beginning of `self`.
mutating func prepend(_ newHead: Int)

			/// Returns a `List` containing `head` followed by the elements
			/// of `self`.
			func prepending(_ head: Element) -> List

			/// Removes and returns the first element of `self` if non-empty;
			/// returns `nil` otherwise.
			mutating func popFirst() -> Element?
			```
			
			Note: in rare cases like popFirst above, the summary is formed of multiple sentence fragments separated by semicolons.

		* Describe what a subscript accesses:

			```
			/// Accesses the `index`th element.
			subscript(index: Int) -> Element { get set }
			```
		* Describe what an initializer creates:

			```
			/// Creates an instance containing `n` repetitions of `x`.
			init(count n: Int, repeatedElement x: Element)
			```

		* For all other declarations, describe what the declared entity is.

			```
			/// A collection that supports equally efficient insertion/removal
			/// at any position.
			struct List {

				/// The element at the beginning of `self`, or `nil` if self is
				/// empty.
				var first: Element?
				...
			```
			
	* **선택 사항**으로 하나 이상의 문단이나 글머리 항목을 추가할 수 있습니다. 문단은 빈 행으로 구분하며 완전한 문장이 되도록 합니다.

		```
		/// Writes the textual representation of each    ← Summary
		/// element of `items` to the standard output.
		///                                              ← Blank line
		/// The textual representation for each item `x` ← Additional discussion
		/// is generated by the expression `String(x)`.
		///
		/// - Parameter separator: text to be printed    ⎫
		///   between items.                             ⎟
		/// - Parameter terminator: text to be printed   ⎬ Parameters section
		///   at the end.                                ⎟
		///                                              ⎭
		/// - Note: To print without a trailing          ⎫
		///   newline, pass `terminator: ""`             ⎟
		///                                              ⎬ Symbol commands
		/// - SeeAlso: `CustomDebugStringConvertible`,   ⎟
		///   `CustomStringConvertible`, `debugPrint`.   ⎭
		public func print(
			_ items: Any..., separator: String = " ", terminator: String = "\n")
		```

		* Use recognized symbol documentation markup elements to add information beyond the summary, whenever appropriate.

		* Know and use recognized bullet items with symbol command syntax. Popular development tools such as Xcode give special treatment to bullet items that start with the following keywords:

			Attention | Author | Authors | 	Bug
			---|---|---|---
			Complexity | Copyright | Date | Experiment
			Important | Invariant | Note | Parameter
			Parameters | Postcondition | Precondition | Remark
			Requires | Returns | SeeAlso | Since
			Throws | Todo | Version | Warning
		
### 이름짓기 (Naming)

#### 사용법을 분명하게 Promote Clear Usage

* **Include all the words needed to avoid ambiguity** for a person reading code where the name is used.

* **Omit needless words.** Every word in a name should convey salient information at the use site.

* **Name variables, parameters, and associated types according to their roles**, rather than their type constraints.

* **Compensate for weak type information** to clarify a parameter’s role.

#### Strive for Fluent Usage

* Prefer method and function names that make use sites form grammatical English phrases.

* Begin names of factory methods with “make”, e.g. x.makeIterator().

* Initializer and factory method calls should form a phrase that does not include the first argument, e.g. x.makeWidget(cogCount: 47)

* Name functions and methods according to their side-effects

	* Those without side-effects should read as noun phrases, e.g. x.distance(to: y), i.successor().

	* Those with side-effects should read as imperative verb phrases, e.g., print(x), x.sort(), x.append(y).

	* Name Mutating/nonmutating method pairs consistently. A mutating method will often have a nonmutating variant with similar semantics, but that returns a new value rather than updating an instance in-place.

		* When the operation is naturally described by a verb, use the verb’s imperative for the mutating method and apply the “ed” or “ing” suffix to name its nonmutating counterpart.
		
			Mutating | Nonmutating
			---|---
			`x.sort()` | `z = x.sorted()`
			`x.append(y)` |	`z = x.appending(y)`
			
		* When the operation is naturally described by a noun, use the noun for the nonmutating method and apply the “form” prefix to name its mutating counterpart.

			Nonmutating | Mutating
			---|---
			`x = y.union(z)` | `y.formUnion(z)`
			`j = c.successor(i)` | `c.formSuccessor(&i)`

* Uses of Boolean methods and properties should read as assertions about the receiver when the use is nonmutating, e.g. x.isEmpty, line1.intersects(line2).

* Protocols that describe what something is should read as nouns (e.g. Collection).

* Protocols that describe a capability should be named using the suffixes able, ible, or ing (e.g. Equatable, ProgressReporting).

* The names of other types, properties, variables, and constants should read as nouns.			

#### Use Terminology Well

Term of Artnoun - a word or phrase that has a precise, specialized meaning within a particular field or profession.

* Avoid obscure terms if a more common word conveys meaning just as well. Don’t say “epidermis” if “skin” will serve your purpose. Terms of art are an essential communication tool, but should only be used to capture crucial meaning that would otherwise be lost.

* Stick to the established meaning if you do use a term of art.

* Avoid abbreviations. Abbreviations, especially non-standard ones, are effectively terms-of-art, because understanding depends on correctly translating them into their non-abbreviated forms.
	
	> The intended meaning for any abbreviation you use should be easily found by a web search.

* Embrace precedent. Don’t optimize terms for the total beginner at the expense of conformance to existing culture.

### Conventions

#### General Conventions

* Document the complexity of any computed property that is not O(1). People often assume that property access involves no significant computation, because they have stored properties as a mental model. Be sure to alert them when that assumption may be violated.

* Prefer methods and properties to free functions. Free functions are used only in special cases:

* Follow case conventions. Names of types and protocols are UpperCamelCase. Everything else is lowerCamelCase.

* Methods can share a base name when they share the same basic meaning or when they operate in distinct domains.

#### Parameters

```swift
func move(from start: Point, to end: Point)
```

* Choose parameter names to serve documentation. Even though parameter names do not appear at a function or method’s point of use, they play an important explanatory role.

* Take advantage of defaulted parameters when it simplifies common uses. Any parameter with a single commonly-used value is a candidate for a default.

* Prefer to locate parameters with defaults toward the end of the parameter list. Parameters without defaults are usually more essential to the semantics of a method, and provide a stable initial pattern of use where methods are invoked.

#### Argument Labels

```swift
func move(from start: Point, to end: Point)
x.move(from: x, to: y) 
```

* Omit all labels when arguments can’t be usefully distinguished, e.g. min(number1, number2), zip(sequence1, sequence2).

* In initializers that perform value preserving type conversions, omit the first argument label, e.g. Int64(someUInt32)

* When the first argument forms part of a prepositional phrase, give it an argument label. The argument label should normally begin at the preposition, e.g. x.removeBoxes(havingLength: 12).

* Otherwise, if the first argument forms part of a grammatical phrase, omit its label, appending any preceding words to the base name, e.g. x.addSubview(y)

* Label all other arguments.

<a name="#special-instructions"></a>
### Special Instructions

* Label closure parameters and tuple members where they appear in your API.

* Take extra care with unconstrained polymorphism (e.g. Any, AnyObject, and unconstrained generic parameters) to avoid ambiguities in overload sets.