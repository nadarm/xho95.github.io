---
layout: post
comments: true
title:  "Swift 5.2: Closures (잠금 블럭)"
date:   2020-02-29 11:30:00 +0900
categories: Swift Language Grammar Closure
---

> Apple 에서 공개한 [The Swift Programming Language (Swift 5.2)](https://docs.swift.org/swift-book/) 책의 [Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html) 부분[^Closures]을 정리한 글입니다.

## Closures

_클로저 (Closures)_ [^closure]는 코드 내에서 사용할 수도 있고 여기 저기 전달할 수도 있는 '독립된 기능 블럭 (self-contained blocks of functionality)' 을 말합니다. 스위프트의 클로저는 C 언어나 오브젝티브-C 언어의 '블럭 (blocks)', 또는 다른 프로그래밍 언어에서의 '람다식 (lambdas)' 과 비슷합니다.

클로저는 자신이 정의된 영역에 있는 모든 상수와 변수의 참조를 가로채서 (capture) 저장할 수 있습니다. 이를 보고 그 상수와 변수를 _걸어 잠근다 (closing over)_ 고 합니다. 가로채는 (capture) 데 필요한 모든 메모리 관리는 스위프트가 알아서 처리합니다.

> 낚아챈다는 개념에 익숙하지 않아도 겅정할 필요 없습니다. 뒤에 나오는 **Capturing Values (값을 낚아채기)** 에서 더 자세히 알아볼 겁니다.

**Functions (함수)** 에서 소개한 '전역 함수 (global functions)' 및 '숨겨진 함수 (nested functions)' 는 사실 클로저 중에서 특수한 경우에 해당합니다. 클로저는 다음 세 가지 형태를 취합니다:

* 전역 함수는 이름을 갖고 있지만 어떤 값도 가로채지 않는 클로저입니다.
* 감춰진 함수 (nested functions) 는 이름을 갖고 있으며 자신을 감싸고 있는 함수의 값을 가로챌 수 있는 클로저입니다.
* 클로저 표현식 (closure expressions) 은 이름이 없으며 자기 주위 영역에 있는 값을 가로챌 수 있는 클로저를 말하며, 간단한 문법 (lightweight syntax) 으로 작성할 수 있습니다.

스위프트의 클로저 표현식은 깔끔하고 명료한 스타일을 가지고 있으며, 최적화 기능을 지원하는데 일반적으로 사용할 때 간결하고 실수를 방지하는 문법을 쓰도록 유도합니다. 이러한 최적화에는 다음과 같은 것들이 있습니다:

* 영역 내에 있는 매개 변수와 반환 값의 타입을 추론
* 한 문장으로 된 (single-expression) 클로저는 자동 반환
* 인자 이름에 약칭 (shorthand)[^shorthand] 사용 지원
* 끝자락 클로저 문법 (trailing closure syntax)[^trailing] 지원

### Closure Expressions (클로저 표현식)

[**Nested Functions (숨겨진 함수)**](http://xho95.github.io/swift/language/grammar/nested/2017/03/02/Nested-Types.html) 부분에서 소개한 '숨겨진 함수'는, 큰 함수 내에서 '독립된 코드 블록'을 정의하고 이름 붙이는 나름 편리한 방법입니다. 그러나 일일이 선언하고 이름 붙일 필요 없이 좀 더 간단하게 함수 같은 것을 만들 수 있다면 더 좋을 겁니다. 이는 특히 함수나 메소드의 인자로 함수들을 넘겨줘야할 때 더 그렇습니다.

_클로저 표현식_ 은 간결하고 알맞은 문법으로 '삽입 클로저 (inline closure)'[^inline-closure] 를 만드는 방법입니다. 클로저 표현식은 여러 가지의 최적화된 문법을 제공하기 때문에, 클로저를 아주 짧은 형태로 만들 수도 있으며, 이렇게 해도 작성한 의도는 명확히 이해할 수 있습니다. 이제부터 예제를 통해 클로저 표현식에서 제공하는 최적화에 대해 알아볼 것인데, 동일한 `sorted(by:)` 메소드가 반복될 때마다 기능은 유지하면서 점점 더 간단하게 표현되는 과정을 보이도록 합니다.

#### The Sorted Method (정렬 메소드)

스위프트의 표준 라이브러리는 `sorted(by:)` 메소드를 제공하는데, 기능은 알려진 타입의 배열 값들을 정렬하는 것으로, 정렬 기준은 사용자가 제공하는 '정렬 클로저 (sorting closure)' 의 호출 결과를 따릅니다. 정렬 과정이 끝나면 `sorted(by:)` 메소드는 예전과 타입과 크기가 같은 새 배열을 반환하며, 이 때 요소들은 올바르게 정렬된 순서입니다. `sorted(by:)` 메소드는 원래 배열은 수정하지 않습니다.

이제부터 `sorted(by:)` 메소드로 `String` 값 배열을 알파벳 역순으로 정렬하는 클로저 표현식 예제를 살펴보겠습니다. 정렬되기 전 최초 상태는 다음과 같습니다:

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
```

`sorted(by:)` 메소드는 인자로 하나의 클로저를 가지는데, 이 클로저는 배열 요소와 타입이 같은 두 개의 인자를 받아서, 값이 정렬됐을 때 첫 번째 값이 두 번째 값의 앞에 와야할지 뒤에 와야할 지를 결정하는 `Bool` 값을 반환합니다. 이 '정렬 클로저' 는 첫 번째 값이 두 번째 값 _앞에_ 나와야하면 `true` 를 반환하고, 아닐 경우 `false` 를 반환해야 합니다.

이 예제는 `String` 값의 배열을 정렬하므로, 정렬 클로저는 `(String, String) -> Bool` 타입의 함수여야 합니다.

'정렬 클로저' 를 제공하는 방법에는 보통의 함수를 타입이 맞게 만든 다음 `sorted(by:)` 메소드의 인자로 넘기는 것도 있습니다:

```swift
func backward(_ s1: String, _ s2: String) -> Bool {
  return s1 > s1
}
var reversedNames = names.sorted(by: backward)
// reversedNames 는 ["Ewa", "Daniella", "Chris", "Barry", "Alex"] 와 같아집니다.
```

첫 번째 문자열 (`s1`) 이 두 번째 문자열 (`s2`) 보다 크면, `backward(_:_:)` 함수는 `true` 를 반환해서, 정렬된 배열에서 `s1` 이 `s2` 앞에 나타나야 할 것임을 나타낼 것입니다. 문자열에 있는 문자가 "보다 큼" 은 "알파벳에서 더 뒤에 나타남" 을 의미합니다. 이는 문자 `"B"` 가 문자 `"A"` "보다 큼" 을 뜻하고, 문자열 `"Tom"` 이 문자열 `"Tim"` "보다 큼" 을 의미합니다. 이런 식으로 `"Barry"` 가 `"Alex"` 앞에 오고, 이렇게 반복해서 알파벳 역순으로 정렬됩니다.

하지만 솔직히 필요한 것은 한 문장으로 된 함수 (`a > b`) 일 뿐인데, 이 방법은 좀 지루하다고 할 수 있습니다. 이제부터 '클로저 표현식 문법' 을 활용해서 삽입된 (inline)[^inline-closure] '정렬 클로저' 를 만드는 더 좋은 방법을 알아보겠습니다.

#### Closure Expression Syntax (클로저 표현식 문법)

클로저 표현식의 기본 문법은 다음과 같습니다:

{(`parameters (매개 변수)`) -> `return type (반환 타입)` in
  `statements (문장)`
}

클로저 표현식의 _매개 변수_ 는 '입-출력 매개 변수 (in-out parameters)'[^in-out] 여도 상관없지만, 기본값은 가질 수 없습니다. '가변개수 매개 변수 (variadic parameters)의 이름을 지정했다면 '가변개수 매개 변수' 도 사용할 수 있습니다. '튜플 (tuples)' 도 매개 변수 타입과 반환 타입으로 사용할 수 있습니다.

아래 예제는 위에 있는 `backward(_:_:)` 함수의 클로저 표현식 버전을 보여줍니다:

```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
  return s1 > s2
})
```

위의 '삽입 클로저 (inline closure)' 에서 매개 변수와 반환 타입을 선언 하는 부분이 `backward(_:_:)` 함수와 완전히 똑같다는 것에 주목합니다. 두 경우 모두 `(s1: String, s2: String) -> Bool` 로 작성했습니다. 그러나 '삽입 클로저 표현식 (inline closure expression)' 에서는 매개 변수와 리턴 타입이 중괄호 밖이 아니라 _안에_ 적혀 있습니다.

클로저 본문 자체는 `in` 키워드로 시작합니다. 이 키워드는 클로저의 매개 변수와 반환 타입에 대한 정의가 끝났으며, 클로저 본문이 시작될 것임을 알려줍니다.

클로저 본문이 아주 짧으므로, 한 줄로도 작성할 수 있습니다.

```swift
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )
```

이 전체도 `sorted(by:)` 메소드를 호출하는 기능을 동일하게 유지합니다. 여전히 한 쌍의 중괄호가 메소드의 전체 인자를 감싸고 있습니다. 하지만 이제 이 인자는 '삽입 클로저 (inline closure)' 입니다.[^inline-closure-question]

#### Inferring Type From Context (문맥으로 타입 추론하기)

'정렬 클로저' 는 메소드에 인자로 전달되므로, 스위프트가 이 매개 변수들의 타입과 반환하는 값의 타입을 추론할 수 있습니다. `sorted(by:)` 메소드는 문자열 배열에서 호출되므로, 인자는 `(String, String) -> Bool` 타입의 함수일 수 밖에 없을 것입니다. 이 말은 클로저 표현식을 작성할 때 `(String, String)` 이나 `Bool` 같은 타입은 작성할 필요가 없다는 뜻입니다. 모든 타입을 추론할 수 있으므로, '반환 표시 화살표 (`->`)' 와 매개 변수 이름 주위의 괄호도 생략 할 수 있습니다:

```swift
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )
```

클로저를 함수나 메소드에 전달할 때 '삽입 클로저 표현식' 을 쓰면, 매개 변수의 타입과 반환 타입을 항상 추론할 수 있습니다. 결과적으로, 클로저를 함수나 메소드의 인자로 사용할 때는, 이 '삽입 클로저' 를 완전한 형태로 작성할 일이 없습니다.

그럼에도 불구하고, 원한다면 언제든 타입을 명시적으로 나타낼 수도 있고, 또 코드를 읽을 때 모호함을 피하고 싶으면 이렇게 하는게 좋긴 합니다. `sorted(by:)` 메소드의 경우 클로저의 목적이 정렬임이 명확하며, 문자열 배열의 정렬을 지원하고 있으므로 누가 봐도 클로저가 `String` 값을 사용할 것이라고 가정하는 데 별 문제 없습니다.

#### Implicit Returns from Single-Expression Closures ('한 문장으로 된 클로저' 의 자동 반환)

'한 문장으로 된 클로저' 는 선언할 때 `return` 키워드를 생략하면 그 문장이 자동으로 반환되며, 이 방법으로 앞의 예제를 고치면 다음과 같습니다:

```swift
reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
```

여기서 `sorted(by:)` 메소드 인자의 '함수 타입'으로부터, 이 클로저는 반드시 `Bool` 값을 반환할 것임이 분명합니다. 또한 클로저 본문은 `Bool` 값을 반환하는 한 문장의 표현식 (`s1> s2`) 으로 되어 있어서, 헷갈릴 일이 없으므로, `return` 키워드를 생략해도 문제가 없습니다.

#### Shorthand Argument Names (인자 이름으로 약칭 사용하기)

스위프트는 '삽입 클로저' 에 자동으로 인자 이름의 약칭을 제공하기 때문에, 클로저 인자 값을 가리킬 때 `$0`, `$1`, `$2` 등을 사용하면 됩니다.

클로저 표현식 내에서 인자 이름 대신 약칭을 사용하는 경우, 클로저의 '인자 목록 (argument list)' 을 정의에서 생략할 수 있으며, 인자 이름을 대신할 약칭의 개수와 타입은 함수 타입으로부터 추론됩니다. `in` 키워드도 생략 가능한데, 이는 클로저 표현식에 본문 밖에 없기 때문입니다:

```swift
reversedNames = names.sorted(by: { $0 > $1 } )
```

여기서 `$0` 과 `$1` 은 각각 클로저의 첫 번째와 두 번째 `String` 인자를 가리킵니다.

#### Operator Methods (연산자 메소드)

실제로는 위의 클로저 표현식을 더 짧게 작성할 수 있습니다. 스위프트의 `String` 타입은 문자열에 특화된 '보다 큰 연산자 (`>`)' 를 메소드로 자체 정의하고 있는데, 두 개의 `String` 타입 매개 변수를 가지고 `Bool` 타입 값을 반환합니다. 이것은 `sorted(by:)` 메소드에서 요구하는 메소드 타입과 정확히 일치합니다. 따라서 단순히 이 '보다 큰 연산자' 를 전달하기만 하면 스위프트가 알아서 문자열에 특화된 구현으로 추론해서 사용합니다.

```swift
reversedNames = names.sorted(by: >)
```

연산자 메소드에 대한 더 자세한 내용은 **Operator Methods (연산자 방법)** 을 참조하십시오.

### Trailing Closures

### Capturing Values

### Closures Are Reference Types

### Escaping Closures

### Autoclosures

### 생각거리

### 참고 자료

[^Closures]: 원문은 [Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html)에서 확인할 수 있습니다.

[^closure]: 'closure' 는 '걸어 잠금'을 뜻하는 단어인데, 스위프트에서 용어로 사용할 때는 '클로저'라고 발음 그대로 옮기고 필요할 때마다 '잠금 블럭'의 의미로 옮기도록 합니다.

[^shorthand]: 'shorthand' 는 '약칭' 이라는 말로 옮겼는데, 클로저 내에서 사용할 수 있는 `$0` 등을 말합니다.

[^trailing]: 'trailing' 은 마지막에 이어져서 따라오는 것을 뜻하며, 스위프트에서는 함수의 마지막 인자에 위치하는 클로저는 함수의 밖으로 꺼내서 표기할 수 있습니다.

[^in-out]: 스위프트의 입-출력 매개변수 (in-out parameters) 는 C 나 C++ 의 참조 (reference) 와 비슷하며, 함수 내부에서 인자의 값을 바꿀 수 있음을 나타냅니다.

[^inline-closure]: 'inline closure' 는 코드 내에서 해당 위치에 직접 입력된 클로저를 말합니다. 예를 들어 클로저를 인자로 전달할 때, 해당 인자 위치에 바로 작성하는 클로저를 말합니다. 우리 말로 적당하게 표현할 방법을 찾지 못해서 일단은 '삽입 클로저' 라고 옮깁니다.

[^inline]: 'inline closure`'[^inline-closure] 부분에서 설명한 대로, 일단 'inline' 은 삽입하다는 의미로 옮깁니다.  

[^inline-closure-question]: 원문의 표현대로라면 이렇게 한 줄로 작성될 때만 '삽입 클로저' 라고 할 수 있는 것 같은데, 아직 이 부분은 정확하게는 모르겠습니다. 궁금하신 분은 [원문](https://docs.swift.org/swift-book/LanguageGuide/Closures.html#ID95) 에서 해당 부분을 확인해 보시기 바랍니다.
