---
layout: post
comments: true
title:  "Swift 5.2: Generics (제네릭; 일반화)"
date:   2020-02-29 11:30:00 +0900
categories: Swift Language Grammar Generic
---

> Apple 에서 공개한 [The Swift Programming Language (Swift 5.3)](https://docs.swift.org/swift-book/) 책의 [Generics](https://docs.swift.org/swift-book/LanguageGuide/Generics.html) 부분[^Generics]을 번역하고, 설명이 필요한 부분은 주석을 달아서 정리한 글입니다.
>
> 현재 번역이 진행 중인데, 2020-06-22 에 Swift 5.3 이 발표되어, 이미 번역된 부분과 남은 부분 모두 Swift 5.3 을 기준으로 옮기도록 합니다. 완료된 목록은 [Swift 5.3: Swift Programming Language (스위프트 프로그래밍 언어)]({% post_url 2017-02-28-The-Swift-Programming-Language %}) 에서 확인할 수 있으며, 일부는 Swift 5.2 기준일 수 있습니다.

## Generics (제네릭; 일반화)

_제네릭 코드 (generic code; 일반화된 코드)_ 를 사용하면, 자신이 정의한 '필수 조건 (requirements)' 에 따라서, 어떠한 타입과도 같이 사용할 수 있는 유연하고, 재사용 가능한 함수와 타입을 작성할 수 있습니다. 중복은 피하고 의도는 명확하고, 추상적인 방법으로 표현되는 코드를 작성할 수 있습니다.

'제네릭 (generic)' 은 스위프트의 가장 강력한 특징 중의 하나로써, 대부분의 스위프트 표준 라이브러리는 제네릭 코드로 제작되어 있습니다. 사실, 인식하지 못했겠지만, _언어 설명서 (Language Guide)_[^language-guide] 전반에 걸쳐 제네릭을 계속 사용하고 있는 중입니다. 예를 들어, 스위프트의 `Array` 와 `Dictionary` 타입은 둘 다 모두 '제네릭 컬렉션 (genenric colletion; 일반화된 집합체)' 입니다. `Int` 값을 가지는 배열을 생성할 수도 있고, `String` 값을 가지는 배열을 생성할 수도 있으며, 아니면 진짜 다른 어떤 타입에 대한 배열도 스위프트에서는 생성할 수 있습니다. 이와 비슷하게, 딕셔너리는 지정된 어떠한 타입의 값도 저장할 수 있으며, 해당 타입으로 무엇이 가능한 지에 대한 제한 자체가 없습니다.

### The Problem That Generics Solve (제네릭이 해결하는 문제)

다음은, 두 개의 `Int` 값을 서로 바꾸는, `swapTwoInts(_:_:)` 라는 표준적인, 제네릭이-아닌 함수입니다:

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
  let temporaryA = a
  a = b
  b = temporaryA
}
```

이 함수는, [In-Out Parameters (입-출력 매개 변수)]({% post_url 2020-06-02-Functions %}#in-out-parameters-입-출력-매개-변수) 에서 설명한 것처럼, 입-출력 매개 변수를 사용하여 `a` 와 `b` 의 값을 서로 바꿉니다.

`swapTwoInts(_:_:)` 함수는 `b` 의 원래 값은 `a` 로, `a` 의 원래 값은 `b` 로 바꿉니다. 이 함수를 호출하면 두 개의 `Int` 변수에 있는 값을 서로 바꿀 수 있습니다:

```swift
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// "someInt is now 107, and anotherInt is now 3" 를 출력합니다.
```

`swapTwoInts(_:_:)` 함수는 유용하긴 하지만, `Int` 값에 대해서만 사용할 수 있습니다. 두 개의 `String` 값이나, 두 개의 `Double` 값을 바꾸고 싶으면, 함수를 더 작성해야 하는데, 이는 아래에 나타낸 `swapTwoStrings(_:_:)` 및 `swapTwoDoubles(_:_:)` 함수와 같은 것들입니다:

```swift
func swapTwoStrings(_ a: inout String, _ b: inout String) {
  let temporaryA = a
  a = b
  b = temporaryA
}

func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
  let temporaryA = a
  a = b
  b = temporaryA
}
```

보면 알겠지만 `swapTwoInts(_:_:)`, `swapTwoStrings(_:_:)`, 그리고 `swapTwoDoubles(_:_:)` 함수의 본문은 모든 점에서 똑같습니다. 유일한 차이점이라면 이들이 받아 들이는 값의 타입 (`Int`, `String`, 및 `Double`) 입니다.

더 유연하고, 확연하게 유연한 것은, _어떤 (any)_ 타입의 두 값이라도 서로 바꿀 수 있는 단일한 함수를 작성하는 것입니다. '제네릭 코드 (generic code; 일반화된 코드)' 는 이러한 함수를 작성할 수 있게 해줍니다. (이 함수의 제네릭 버전은 아래에서 정의합니다.)

> 세 함수 모두에서, `a` 와 `b` 의 타입은 반드시 같아야 합니다. `a` 와 `b` 가 같은 타입이 아닐 경우, 이들의 값을 서로 바꿀 수 없습니다. 스위프트는 타입-안전한 언어이며, (예를 들어) `String` 타입의 변수와 `Double` 타입의 변수가 서로 값을 바꾸는 것을 허용하지 않습니다. 이렇게 하는 것은 '컴파일-시간 에러' 로 끝납니다.

### Generic Functions (제네릭 함수; 일반화된 함수)

'제네릭 함수 (generic functions; 일반화된 함수)' 는 어떤 타입과도 작업할 수 있습니다. 다음은 위에 있는 `swapTwoInts(_:_:)` 함수의 일반화된 버전인, `swapTwoValues(_: _:)` 입니다:

```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
  let temporaryA = a
  a = b
  b = temporaryA
}
```

`swapTwoValues(_:_:)` 함수의 본문은 `swapTwoInts(_:_:)` 함수의 본문과 모든 점에서 똑같습니다. 하지만, `swapTwoValues(_:_:)` 와 `swapTwoInts(_:_:)` 는 첫 번째 줄이 약간 다릅니다. 다음은 첫 번째 줄을 비교한 것입니다:

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int)
func swapTwoValues<T>(_ a: inout T, _ b: inout T)
```

제네릭 버전의 함수는 _실제 (actual)_ 타입 이름 (가령 `Int`, `String`, 또는 `Double`) 대신에 _자리 표시용 (placeholder)_ 타입 이름 (이 경우는, `T`) 를 사용합니다. 자리 표시용 타입 이름은 `T` 가 뭐여야 하는 지에 대해서는 대해서는 어떤 것도 말하지 않지만, `T` 가 뭐든지 간에, `a` 와 `b` 가 반드시 `T` 라는 같은 타입이어야 함은 말 _합니다 (does)_. `T` 의 자리에 사용될 실제 타입은 `swapTwoValues​​(_:_:)` 함수를 호출하는 매 순간 결정됩니다.

제네릭 함수와 제네릭이 아닌 함수의 또 다른 차이점은 제네릭 함수의 이름 (`swapTwoValues​​(_:_:)`) 뒤에는 자리 표시용 타입 이름 (`T`) 이 꺾쇠 괄호 (`<T>`) 에 담겨 있다는 것입니다. 이 괄호는 `T` 가 `swapTwoValues​​(_:_:)` 함수 정의 내에서 자리 표시용 타입 이름이 된다는 것을 스위프트에게 알려줍니다. `T` 는 자리 표시 용도이기 때문에, 스위프트는 `T` 에 대한 실제 타입을 찾지 않습니다.

`swapTwoValues​​(_:_:)` 함수는 이제, 둘 모두 서로 같은 타입인 한, _어떤 (any)_ 타입에 대한 두 값도 전달할 수 있다는 것만 빼면, `swapTwoInts` 와 똑같은 방법으로 호출할 수 있습니다. `swapTwoValues​​(_:_:)` 를 호출할 때마다, `T` 에서 사용할 타입이 함수에 전달되는 값의 타입으로 추론됩니다.

아래의 두 예제에서, `T` 는 각각 `Int` 와 `String` 으로 추론됩니다:

```swift
var someInt = 3
var anotherInt = 107
swapTwoValues(&someInt, &anotherInt)
// someInt 는 이제 107 이고, anotherInt 는 이제 3 입니다.

var someString = "hello"
var anotherString = "world"
swapTwoValues(&someString, &anotherString)
// someString 은 이제 "world" 이고, anotherString 은 이제 "hello" 입니다.
```

> 위에서 정의한 `swapTwoValues(_:_:)` 함수는, 스위프트 표준 라이브러리의 일부이며, 자동으로 앱 개발에 사용할 수 있는, `swap` 이라는 '제네릭 함수 (generic function; 일반화된 함수)' 에서 영감을 받은 것입니다. 코드에서 `swapTwoValues(_:_:)` 함수와 같은 동작이 필요한 경우, 직접 구현을 제공하는 것 대신 스위프트의 기존 `swap(_:_:)` 함수를 사용할 수 있습니다.

### Type Parameters (타입 매개 변수)

위의 `swapTwoValues(_:_:)` 예제에서, 자리 표시용 타입인 `T` 는 _타입 매개 변수 (type parameter)_ 의 한 가지 예입니다. '타입 매개 변수' 는 자리 표시용 타입을 지정하고 이름을 정하는 것으로, 함수 이름 바로 뒤, 해당하는 꺽쇠 괄호 쌍의 사이에 (`<T>` 와 같이) 작성합니다.

일단 한번 타입 매개 변수를 지정하면, 이를 사용하여 (가령 `swapTwoValues(_:_:)` 함수의 `a` 와 `b` 매개 변수 처럼) 함수 매개 변수의 타입을 정의하거나, 함수의 반환 타입을 정의하거나, 아니면 함수 본문 내에서 '타입 보조 설명 (type annotation)' 정의할 수 있습니다. 각각의 경우, 함수를 호출할 때마다 타입 매개 변수를 _실제 (actual)_ 타입으로 대체합니다. (위의 `swapTwoValues(_:_:)` 예제에서, `T` 는 함수를 처음 호출할 때는 `Int` 로 대체되고, 두번째 호출할 때는 `String` 으로 대체되었습니다.)

하나 이상의 타입 매개 변수를 제공하려면 꺾쇠 괄호 안에, 쉼표로 구분하여, 여러 개의 타입 매개 변수 이름을 작성하면 됩니다.

### Naming Type Parameters (타입 매개 변수 이름짓기)

### Generic Types

### Extending a Generic Type

### Type Constraints (타입 구속 조건)

`swapTwoValues​​(_:_:)` 함수와 `Stack` 타입은 어떤 타입과도 작업할 수 있습니다. 하지만, 일반화된 함수 및 일반화된 타입과 같이 사용할 수 있는 타입에 대해 _타입 구속 조건 (type constraints)_ 정하도록 강제하는 것이 유용할 때가 있습니다. '타입 구속 조건' 은 '타입 매개 변수' 가 지정된 클래스를 반드시 상속하거나, 아니면 특정한 프로토콜 또는 프로토콜 조합을 반드시 준수하도록 지정합니다.

예를 들어, 스위프트의 `Dictionary` 타입은 '딕셔너리' 의 키로 사용할 수 있는 타입에 대한 제한을 가지고 있습니다. [Dictionaries (딕셔너리; 사전)]({% post_url 2016-06-06-Collection-Types %}#dictionaries-딕셔너리-사전) 에서 설명한대로, 딕셔너리의 키 타입은 반드시 '_해시 가능 (hashable)_' 해야 합니다. 다시 말해서, 그 자신을 유일하게 표현할 수 있는 방법을 반드시 제공해야 합니다. `Dictionary` 의 키가 '해시 가능 (hashable)' 해야만 특정 키에 대한 값을 이미 가지고 있는 지 검사할 수 있습니다. 이 '필수 조건 (requirement)' 이 없다면, `Dictionary` 가 특정 키에 대해서 값을 집어 넣어야 하는지 교체해야 하는 지 알 수 없을 뿐만 아니라, 주어진 키에 대해 '딕셔너리' 에 이미 있는 값을 찾을 수도 없게 됩니다.

이 '필수 조건 (requirement)' 은 `Dictionary` 에 대한 키 타입의 '타입 구속 조건 (type constraint)' 으로 강제하는데, 키 타입이, 스위프트 표준 라이브러리에서 정의한 특수한 프로토콜인, `Hashable` 프로토콜을 반드시 준수하도록 지정합니다. 스위프트의 모든 기본 타입들 (가령 `String`, `Int`, `Double`, 그리고 `Bool` 등) 은 기본적으로 '해시 가능 (hashable)' 합니다.

사용자 정의 '일반화된 타입 (generic types)' 을 생성할 때 자신만의 고유 '타입 구속 조건' 을 정의할 수 있으며, 이러한 '구속 조건' 이 '일반화 프로그래밍 (generic programming)' 의 강력함의 대부분을 차지합니다. `Hashable` 과 같은 추상적인 '개념 (concepts)' 은, 구체적인 타입이 아니라, 개념적인 성질의 관점에서 타입의 성격을 규정합니다.

#### Type Constraint Syntax

#### Type Constraints in Action

### Associated Types

#### Associated Types in Action

#### Extending an Existing Type to Specify an Associated Type

#### Adding Constraints to an Associated Type

#### Using a Protocol in Its Associated Type's Constaints

### Generic Where Clauses (일반화된 where 구절)

[Type Constraints (타입 구속 조건)](#type-constraints-타입-구속-조건) 에서 설명한 대로, '타입 구속 조건'을 사용하면 일반화된 함수, 일반화된 첨자 연산자 또는 일반화된 타입들과 결합되어 있는 타입 매개 변수들에 대한 '필수 조건' 을 정의할 수 있습니다.

여기에 더해서 '결합된 타입 (associated type)' 에 대한 '필수 조건' 을 정의할 때도 유용하게 쓸 수 있는데, 이 때는 _일반화된 where 구절_ 을 정의하면 됩니다. 일반화된 `where` 구절을 사용하면 '결합된 타입'이 반드시 특정 프로토콜을 준수해야 한다거나, 특정 '타입 매개 변수'와 '결합된 타입'이 같아야 한다는 요구 사항들을 덧붙일 수 있습니다. 일반화된 `where` 구절은 `where` 키워드로 시작해서, 뒤이어서 '결합된 타입' 에 대한 '구속 조건' 또는 타입과 '결합된 타입' 간의 '동등 관계' 등이 따라옵니다. 일반화된 `where` 구절은 타입이나 함수 본문의 시작 괄호 바로 앞에 작성합니다.

아래 예제는 일반화된 함수인 `allItemsMatch` 를 정의하는데, 이 함수는 두 개의 `Container` 인스턴스가 동일한 요소를 동일한 순서로 갖고 있는지를 검사합니다. 이 함수는 불 (Boolean) 값을 반환하며 모든 요소가 일치하면 `true` 를 그렇지 않으면 `false` 를 반환합니다.

두 컨테이너를 검사할 때 컨테이너의 타입이 같을 필요는 없지만 (물론 같더라도 상관없습니다), 각 요소들의 타입은 같아야 합니다. 이 요구 사항은 '타입 구속 조건 (type constraints)' 과 '일반화된 where 구절' 을 조합하여 표현합니다.

```swift
func allItemsMatch<C1: Container, C2: Container>(_ someContainer: C1, _ anotherContainer: C2) -> Bool where C1.Item == C2.Item, C1.Item: Equatable {
  // Check that both containers contain the same number of items.
  if someContainer.count != anotherContainer.count {
    return false
  }

  // Check each pair of items to see if they're equivalent.
  for i in 0..<someContainer.count {
    if someContainer[i] != anotherContainer[i] {
      return false
    }
  }

  // All items match, so return true.
  return true
}
```

이 함수는 두 인자로 `someContainer` 와 `anotherContainer` 를 사용합니다. `someContainer` 인자는 `C1` 타입이고, `anotherContainer` 인자는 `C2` 타입입니다. `C1` 과 `C2` 는 두 개의 컨테이터 타입을 위한 '타입 매개 변수' 로써 함수가 호출될 때 결정됩니다.

이 함수의 두 '타입 매개 변수'는 아래의 요구 사항들을 갖습니다:

* `C1` 은 반드시 `Container` 프로토콜을 준수해야 합니다. (`C1: Container` 로 적혀 있습니다.)
* `C2` 도 반드시 `Container` 프로토콜을 준수해야 합니다. (`C2: Container` 로 적혀 있습니다.)
* `C1` 의 요소는 `C2` 의 요소와 반드시 동일해야 합니다. (`C1.Item == C2.Item` 로 적혀 있습니다.)[^Items]
* `C1` 의 요소는 반드시 `Equatable` 프로토콜을 준수해야 합니다. (`C1.Item : Equatable` 로 적혀 있습니다.)

첫 번째와 두 번째 요구 사항은 함수의 '타입 매개 변수 목록 (type parameter list)' 에 정의되어 있고, 세 번째와 네 번째 요구 사항은 '일반화된 where 구절' 에 정의되어 있습니다.

이 요구 사항들이 의미하는 것은 다음과 같습니다:

* `someContainer` 는 `C1` 타입의 컨테이너 입니다.
* `anotherContainer` 는 `C2` 타입의 컨테이너 입니다.
* `someContainer` 와 `anotherContainer` 는 같은 타입의 요소를 가집니다.
* `someContainer` 의 요소들은 '같지 않음 연산자 (!=)' 로 서로 다른지를 확인할 수 있어야 합니다.

세 번째와 네 번째 요구 사항을 조합하면 `anotherContainer` 의 요소들도 '같지 않음 연산자 (!=)' 로 검사할 수 있다는 의미가 되는데, 이는 `someContainer` 의 요소와 타입이 똑 같기 때문입니다.

이러한 요구 사항에 덕분에 두 컨테이너의 타입이 달라도 `allItemsMatch(_:_:)` 함수로 비교할 수 있게 되는 것입니다.

`allItemsMatch(_:_:)` 함수는 먼저 두 컨테이너의 요소 개수가 같은지를 검사합니다. 요소의 개수가 다르다면, 서로 같을 수가 없으므로, 함수의 반환 값은 `false` 입니다.

이 검사를 마친 후, `someContainer` 의 모든 요소들에 반복해서 적용할 방법으로 `for-in` 루프와 '반-개방 범위 연산자 (`..<`)'를 사용합니다. 각 요소 마다, `someContainer` 의 요소와 `anotherContainer` 의 요소가 다른지를 검사합니다. 두 요소가 다르다면, 두 컨테이너가 같을 수 없으므로, 함수의 반환 값은 `false` 입니다.

아무런 문제없이 루프를 완료하면, 두 컨테이너가 같은 것이므로, 함수의 반환 값은 `true` 입니다.

`allItemsMatch(_:_:)` 함수의 사용법은 다음과 같습니다:


```swift
var stackOfStrings = Stack<String>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
  print("All items match.")
} else {
  print("Not all items match.")
}

// Prints "All items match."
```

위 예제는 `String` (문자열) 값을 저장하기 위해 `Stack` (스택) 인스턴스를 만들고, 3 개의 문자열을 스택에 집어 넣습니다. 또 `Array` (배열) 인스턴스를 만든 다음 '배열 문자식 (array literal)' 으로 초기화할 때 스택에 넣었던 것과 동일한 3 개의 문자열을 사용합니다. 스택과 배열은 다른 타입이지만, 둘 다 `Container` 프로토콜을 준수하며, 같은 타입의 값을 갖고 있습니다. 따라서 `allItemsMatch(_:_:)` 함수를 호출하면서 이 두 컨테이너를 인자로 넣을 수 있습니다. 위에서 `allItemsMatch(_:_:)` 함수가 두 컨테이터의 모든 요소 값들을 제대로 비교하고 있음을 확인할 수 있습니다.

### Extensions with a Generic Where Clause

### Contextual Where Clauses

### Associated Types with a Generic Where Clause

### Generic Subscripts

### 참고 자료

[^Generics]: 원문은 [Generics](https://docs.swift.org/swift-book/LanguageGuide/Generics.html)에서 확인할 수 있습니다.

[^language-guide]: 'Language Guide (언어 설명서)' 는 'Swift Programming Language' 책에서 스위프트의 문법을 설명하는 부분으로, 지금 보고 있는 글들이 이 'Language Guide' 에 속해 있는 것들입니다.

[^Items]: 이 조건을 만족하면 요소의 값뿐만 아니라, 각 요소들의 타입이 같다는 것도 보장됩니다. 각 요소가 같음을 비교하려면 각 요소의 타입이 같아야 하기 때문입니다.
