---
layout: post
comments: true
title:  "Swift 5.2: Generics (제네릭; 일반화)"
date:   2020-02-29 11:30:00 +0900
categories: Swift Language Grammar Generic
---

> Apple 에서 공개한 [The Swift Programming Language (Swift 5.3)](https://docs.swift.org/swift-book/) 책의 [Generics](https://docs.swift.org/swift-book/LanguageGuide/Generics.html) 부분[^Generics]을 번역하고, 설명이 필요한 부분은 주석을 달아서 정리한 글입니다.
>
> 현재 번역이 진행 중인데, 2020-06-22 에 Swift 5.3 이 발표되어, 이미 번역된 부분과 남은 부분 모두 Swift 5.3 을 기준으로 옮기도록 합니다. 완료된 목록은 [Swift 5.3: Swift Programming Language (스위프트 프로그래밍 언어)]({% post_url 2017-02-28-The-Swift-Programming-Language %}) 에서 확인할 수 있으며, 일부는 Swift 5.2 기준일 수 있습니다.

## Generics (제네릭; 일반화)

_제네릭 코드 (generic code; 일반화된 코드)_ 를 사용하면, 자신이 정의한 '필수 조건 (requirements)' 에 따라서, 어떠한 타입과도 같이 사용할 수 있는 유연하고, 재사용 가능한 함수와 타입을 작성할 수 있습니다. 중복은 피하고 의도는 명확하고, 추상적인 방법으로 표현되는 코드를 작성할 수 있습니다.

'제네릭 (generic)' 은 스위프트의 가장 강력한 특징 중의 하나로써, 대부분의 스위프트 표준 라이브러리는 제네릭 코드로 제작되어 있습니다. 사실, 인식하지 못했겠지만, _언어 설명서 (Language Guide)_[^language-guide] 전반에 걸쳐 제네릭을 계속 사용하고 있는 중입니다. 예를 들어, 스위프트의 `Array` 와 `Dictionary` 타입은 둘 다 모두 '제네릭 컬렉션 (genenric colletion; 일반화된 집합체)' 입니다. `Int` 값을 가지는 배열을 생성할 수도 있고, `String` 값을 가지는 배열을 생성할 수도 있으며, 아니면 진짜 다른 어떤 타입에 대한 배열도 스위프트에서는 생성할 수 있습니다. 이와 비슷하게, 딕셔너리는 지정된 어떠한 타입의 값도 저장할 수 있으며, 해당 타입으로 무엇이 가능한 지에 대한 제한 자체가 없습니다.

### The Problem That Generics Solve (제네릭이 해결하는 문제)

다음은, 두 개의 `Int` 값을 서로 바꾸는, `swapTwoInts(_:_:)` 라는 표준적인, 제네릭이-아닌 함수입니다:

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
  let temporaryA = a
  a = b
  b = temporaryA
}
```

이 함수는, [In-Out Parameters (입-출력 매개 변수)]({% post_url 2020-06-02-Functions %}#in-out-parameters-입-출력-매개-변수) 에서 설명한 것처럼, 입-출력 매개 변수를 사용하여 `a` 와 `b` 의 값을 서로 바꿉니다.

`swapTwoInts(_:_:)` 함수는 `b` 의 원래 값은 `a` 로, `a` 의 원래 값은 `b` 로 바꿉니다. 이 함수를 호출하면 두 개의 `Int` 변수에 있는 값을 서로 바꿀 수 있습니다:

```swift
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// "someInt is now 107, and anotherInt is now 3" 를 출력합니다.
```

`swapTwoInts(_:_:)` 함수는 유용하긴 하지만, `Int` 값에 대해서만 사용할 수 있습니다. 두 개의 `String` 값이나, 두 개의 `Double` 값을 바꾸고 싶으면, 함수를 더 작성해야 하는데, 이는 아래에 나타낸 `swapTwoStrings(_:_:)` 및 `swapTwoDoubles(_:_:)` 함수와 같은 것들입니다:

```swift
func swapTwoStrings(_ a: inout String, _ b: inout String) {
  let temporaryA = a
  a = b
  b = temporaryA
}

func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
  let temporaryA = a
  a = b
  b = temporaryA
}
```

보면 알겠지만 `swapTwoInts(_:_:)`, `swapTwoStrings(_:_:)`, 그리고 `swapTwoDoubles(_:_:)` 함수의 본문은 모든 점에서 똑같습니다. 유일한 차이점이라면 이들이 받아 들이는 값의 타입 (`Int`, `String`, 및 `Double`) 입니다.

더 유연하고, 확연하게 유연한 것은, _어떤 (any)_ 타입의 두 값이라도 서로 바꿀 수 있는 단일한 함수를 작성하는 것입니다. '제네릭 코드 (generic code; 일반화된 코드)' 는 이러한 함수를 작성할 수 있게 해줍니다. (이 함수의 제네릭 버전은 아래에서 정의합니다.)

> 세 함수 모두에서, `a` 와 `b` 의 타입은 반드시 같아야 합니다. `a` 와 `b` 가 같은 타입이 아닐 경우, 이들의 값을 서로 바꿀 수 없습니다. 스위프트는 타입-안전한 언어이며, (예를 들어) `String` 타입의 변수와 `Double` 타입의 변수가 서로 값을 바꾸는 것을 허용하지 않습니다. 이렇게 하는 것은 '컴파일-시간 에러' 로 끝납니다.

### Generic Functions (제네릭 함수; 일반화된 함수)

'제네릭 함수 (generic functions; 일반화된 함수)' 는 어떤 타입과도 작업할 수 있습니다. 다음은 위에 있는 `swapTwoInts(_:_:)` 함수의 일반화된 버전인, `swapTwoValues(_: _:)` 입니다:

```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
  let temporaryA = a
  a = b
  b = temporaryA
}
```

`swapTwoValues(_:_:)` 함수의 본문은 `swapTwoInts(_:_:)` 함수의 본문과 모든 점에서 똑같습니다. 하지만, `swapTwoValues(_:_:)` 와 `swapTwoInts(_:_:)` 는 첫 번째 줄이 약간 다릅니다. 다음은 첫 번째 줄을 비교한 것입니다:

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int)
func swapTwoValues<T>(_ a: inout T, _ b: inout T)
```

제네릭 버전의 함수는 _실제 (actual)_ 타입 이름 (가령 `Int`, `String`, 또는 `Double`) 대신에 _자리 표시용 (placeholder)_ 타입 이름 (이 경우는, `T`) 를 사용합니다. 자리 표시용 타입 이름은 `T` 가 뭐여야 하는 지에 대해서는 대해서는 어떤 것도 말하지 않지만, `T` 가 뭐든지 간에, `a` 와 `b` 가 반드시 `T` 라는 같은 타입이어야 함은 말 _합니다 (does)_. `T` 의 자리에 사용될 실제 타입은 `swapTwoValues​​(_:_:)` 함수를 호출하는 매 순간 결정됩니다.

제네릭 함수와 제네릭이 아닌 함수의 또 다른 차이점은 제네릭 함수의 이름 (`swapTwoValues​​(_:_:)`) 뒤에는 자리 표시용 타입 이름 (`T`) 이 꺾쇠 괄호 (`<T>`) 에 담겨 있다는 것입니다. 이 괄호는 `T` 가 `swapTwoValues​​(_:_:)` 함수 정의 내에서 자리 표시용 타입 이름이 된다는 것을 스위프트에게 알려줍니다. `T` 는 자리 표시 용도이기 때문에, 스위프트는 `T` 에 대한 실제 타입을 찾지 않습니다.

`swapTwoValues​​(_:_:)` 함수는 이제, 둘 모두 서로 같은 타입인 한, _어떤 (any)_ 타입에 대한 두 값도 전달할 수 있다는 것만 빼면, `swapTwoInts` 와 똑같은 방법으로 호출할 수 있습니다. `swapTwoValues​​(_:_:)` 를 호출할 때마다, `T` 에서 사용할 타입이 함수에 전달되는 값의 타입으로 추론됩니다.

아래의 두 예제에서, `T` 는 각각 `Int` 와 `String` 으로 추론됩니다:

```swift
var someInt = 3
var anotherInt = 107
swapTwoValues(&someInt, &anotherInt)
// someInt 는 이제 107 이고, anotherInt 는 이제 3 입니다.

var someString = "hello"
var anotherString = "world"
swapTwoValues(&someString, &anotherString)
// someString 은 이제 "world" 이고, anotherString 은 이제 "hello" 입니다.
```

> 위에서 정의한 `swapTwoValues(_:_:)` 함수는, 스위프트 표준 라이브러리의 일부이며, 자동으로 앱 개발에 사용할 수 있는, `swap` 이라는 '제네릭 함수 (generic function; 일반화된 함수)' 에서 영감을 받은 것입니다. 코드에서 `swapTwoValues(_:_:)` 함수와 같은 동작이 필요한 경우, 직접 구현을 제공하는 것 대신 스위프트의 기존 `swap(_:_:)` 함수를 사용할 수 있습니다.

### Type Parameters (타입 매개 변수)

위의 `swapTwoValues(_:_:)` 예제에서, 자리 표시용 타입인 `T` 는 _타입 매개 변수 (type parameter)_ 의 한 가지 예입니다. '타입 매개 변수' 는 자리 표시용 타입을 지정하고 이름을 정하는 것으로, 함수 이름 바로 뒤, 해당하는 꺽쇠 괄호 쌍의 사이에 (`<T>` 와 같이) 작성합니다.

일단 한번 타입 매개 변수를 지정하면, 이를 사용하여 (가령 `swapTwoValues(_:_:)` 함수의 `a` 와 `b` 매개 변수 처럼) 함수 매개 변수의 타입을 정의하거나, 함수의 반환 타입을 정의하거나, 아니면 함수 본문 내에서 '타입 보조 설명 (type annotation)' 정의할 수 있습니다. 각각의 경우, 함수를 호출할 때마다 타입 매개 변수를 _실제 (actual)_ 타입으로 대체합니다. (위의 `swapTwoValues(_:_:)` 예제에서, `T` 는 함수를 처음 호출할 때는 `Int` 로 대체되고, 두번째 호출할 때는 `String` 으로 대체되었습니다.)

하나 이상의 타입 매개 변수를 제공하려면 꺾쇠 괄호 안에, 쉼표로 구분하여, 여러 개의 타입 매개 변수 이름을 작성하면 됩니다.

### Naming Type Parameters (타입 매개 변수 이름짓기)

대부분의 경우, 타입 매개 변수는 '설명 방식의 이름 (descriptive name)' 을 가지는데, 가령 `Dictionary<Key, Value>` 의 `Key` 와 `Value` 및 `Array<Element>` 의 `Element` 가 그런 것으로, 이는 타입 매개 변수와 이것을 사용하는 제네릭 타입 또는 제네릭 함수 사이의 관계에 대해 말해줍니다. 하지만, 이들 사이에 의미있는 관계가 없을 때는, 위의 `swapTwoValues(_:_:)` 함수에 있는 `T` 처럼, `T`, `U` 같은 단일 문자를 사용하여 이름을 짓는 것이 전통입니다.

> 타입 매개 변수는, 값이 아니라, _타입 (type)_ 에 대한 자리를 표시한다는 것을 지시하기 위하여 항상 '대문자로 시작하는 낙타 등 모양 (upper camel case)' 이름을 (가령 `T` 와 `MyTypeParamter` 같이) 부여하도록 합니다.

### Generic Types (제네릭 타입; 일반화된 타입)

제네릭 함수 외에도, 스위프트는 자신만의 _제네릭 타입 (generic types; 일반화된 타입)_ 을 정의할 수 있게 해줍니다. 이는, `Array` 및 `Dictionary` 와 비슷한 방식으로, _어떤 (any)_ 타입과도 같이 작업할 수 있는 사용자 정의 클래스, 구조체, 및 열거체를 말합니다.

이번 장에서는  `Stack` 이라는 '제네릭 컬렉션 타입 (generic colletion type; 일반화된 집합체 타입)' 을 작성하는 방법을 보여줍니다. '스택 (stack)' 은, 배열과 비슷하게, 값이 '정렬된 집합 (ordered set)' 이지만 스위프트의 `Array` 타입보다 더 '제약된 연산 집합 (restricted set of operations)' 을 가집니다. 배열은 배열의 어느 위치에서도 새 항목을 집어 넣거나 제거할 수 있게 합니다. 하지만, 스택은 컬렉션의 끝에서만 새 항목을 덧붙이도록 합니다 (이를 일컬어 스택에 새 값을 _밀어 넣는다 (pushing)_ 라고 합니다). 이와 비슷하게, 스택은 컬렉션의 끝에서만 새 항목을 제거하도록 합니다. (이를 일컬어 스택이 값을 _발사한다 (popping)_ 고 합니다).

> 스택의 개념은 `UINavigationController` 클래스가 자신의 '항법 계층 (navigation hierarchy)' 에 있는 '뷰 컨트롤러 (view controllers)' 를 모델링하는 데 사용하고 있습니다. `UINavigationController` 클래스의 `pushViewController(_:animated:)` 메소드를 호출하여 '항법 스택' 에 뷰 컨트롤러를 추가-또는 밀어 넣기 (push)-하며, `popViewControllerAnimated(_:)` 메소드로 '항법 스택'에서 뷰 컨트롤러를 제거-또는 발사 (pop)-합니다. 스택은 엄격한 "후입 선출법 (LIFO; last in, first out)"[^LIFO] 방식으로 스택을 관리해야할 때마다 유용한 컬렉션 모델입니다.

아래 그림은 스택의 '밀어 넣기 (push)' 와 '발사하기 (pop)' 동작을 보여줍니다:

![Push and Pop of Stack](/assets/Swift/Swift-Programming-Language/Generic-stack-push-and-pop.png)

1. 스택에는 현재 세 개의 값이 있습니다.
2. 네 번째 값을 스택의 최상단에 밀어 넣습니다.
3. 스택은 이제 네 개의 값을 보유하는데, 가장 최근 것이 최상단에 있습니다.
4. 스택에 있는 최상단 항목이 발사됩니다.
5. 값을 발사한 후, 스택은 다시 한번 세 개의 값을 보유합니다.

다음은 제네릭이-아닌 버전의 스택을 작성하는 방법으로, 이 경우는 `Int` 값에 대한 스택입니다:

```swift
struct IntStack {
  var items = [Int]()
  mutating func push(_ item: Int) {
    items.append(item)
  }
  mutating func pop() -> Int {
    return items.removeLast()
  }
}
```

이 구조체는 스택에 값을 저장하기 위해 `items` 라는 `Array` 속성을 사용합니다. `Stack` 은, `push` 와 `pop` 이라는, 두 개의 메소드를 제공하여 스택에 값을 밀어 넣거나 발사합니다. 이 메소드는, 구조체의 `items` 배열을 수정-또는 _변경 (mutate)_-할 필요가 있으므로, `mutating` 이라고 표시합니다.

하지만, 위에 나타낸 `IntStack` 타입은 `Int` 값으로만 사용할 수 있습니다. _어떤 (any)_ 타입의 값이라도 스택으로 관리할 수 있도록, _제네릭 (generic)_ `Stack` 클래스를 정의한다면 훨씬 더 쓸모있을 것입니다.

다음은 같은 코드에 대한 '제네릭 (generic; 일반화된)' 버전입니다:

```swift
struct Stack<Element> {
  var items = [Element]()
  mutating func push(_ item: Element) {
    items.append(item)
  }
  mutating func pop() -> Element {
    return items.removeLast()
  }
}
```

`Stack` 의 제네릭 버전이 본질적으로 제네릭이-아닌 버전과 얼마나 같은지를, 하지만 실제 타입인 `Int` 대신 `Element` 라는 타입 매개 변수를 가지고 있음을 주목하기 바랍니다. 이 타입 매개 변수는 구조체의 이름 바로 뒤 한 쌍의 꺾쇠 괄호 안에 (`<Element>` 라고) 작성되어 있습니다.

`Element` 는 나중에 제공할 타입에 대한 '자리 표시용 이름 (placeholder name)' 을 정의합니다. 이 미래의 타입은 구조체 정의 내의 어디서나 `Element` 로 참조할 수 있습니다. 지금과 같은 경우, `Element` 를 세 곳에서 자리 표시 용으로 사용하고 있습니다:

* `Element` 타입인 값에 대한 빈 배열로 초기화되는, `items` 라는 속성을 생성하기 위해서
* 반드시 `Element` 타입인, `item` 이라는 단일 매개 변수를 가진 `push(_:)` 메소드를 지정하기 위해서
* `pop()` 메소드의 반환 값이 `Element` 타입의 값이 되도록 지정하기 위해서

'제네릭 타입 (generic type; 일반화된 타입)' 이므로, `Stack` 을 사용하면, `Array` 및 `Dictionary` 와 비슷하게, 스위프트에 있는 유효한 _어떤 (type)_ 타입에 대한 스택이라도 생성할 수 있습니다.

새로운 `Stack` 인스턴스를 생성하려면 스택에 저장할 타입을 꺾쇠 괄호 안에 작성하면 됩니다. 예를 들어, 문자열에 대한 새 스택을 생성하려면, `Stack<String>()` 이라고 작성합니다:

```swift
var stackOfStrings = Stack<String>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// 스택은 이제 4 개의 문자열을 담고 있습니다.
```

다음은 이 네 값을 스택에 밀어 넣은 다음에 `stackOfStrings` 이 어떻게 보이게 되는 지를 나타낸 것입니다:

![Pushing of Stack](/assets/Swift/Swift-Programming-Language/Generic-stack-pushing.png)

스택에서 값을 발사하면 최상단 값인, `"cuatro"` 를 제거하고 반환합니다:

```swift
let fromTheTop = stackOfStrings.pop()
// fromTheTop 은 "cuatro" 이 되고, 스택은 이제 3 개의 값을 담고 있습니다.
```

다음은 최상단 값을 발사한 다음에 스택이 어떻게 보이게 되는 지를 나타낸 것입니다:

![Popping of Stack](/assets/Swift/Swift-Programming-Language/Generic-stack-popping.jpg)

### Extending a Generic Type (제네릭 타입 확장하기; 일반화된 타입 확장하기)

제네릭 타입을 확장할 때, '익스텐션 (extension)'[^extension] 을 정의하면서 타입 매개 변수 목록을 제공하지는 않습니다. 그 대신, _원래의 (original)_ 타입 정의에 있는 타입 매개 변수 목록을 익스텐션의 본문에서 사용하는 것이 가능하며, 이 원래의 타입 매개 변수 이름을 사용하여 원래 정의에 있는 타입 매개 변수를 참조합니다.

다음 예제는 제네릭 `Stack` 타입을 확장하여 `topItem` 이라는 읽기-전용 계산 속성을 추가하는데, 이는 스택의 최상단 항목을 스택에서 발사하지 않은채로 반환합니다:

```swift
extension Stack {
    var topItem: Element? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
```

`topItem` 속성은 `Element` 타입인 옵셔널 값을 반환합니다. 만약 스택이 비어 있으면, `topItem` 은 `nil` 을 반환하고; 스택이 비어 있지 않으면, `topItem` 은 `items` 배열의 최종 항목을 반환합니다.

이 '익스텐션' 은 타입 매개 변수 목록을 정의하지 않고 있음에 주목하기 바랍니다. 그 대신, `Stack` 타입의 기존 타입 매개 변수 이름인, `Element` 이, '익스텐션' 에서 `topItem` 계산 속성에 대한 옵셔널 타입을 지시하기 위해 사용되고 있습니다.

이제 `topItem` 계산 속성은 어떤 `Stack` 인스턴스와도 같이 사용할 수 있는데, 이것으로 최상단 항목을 제거하지 않고도 이에 접근하고 조회할 수 있습니다.

```swift
if let topItem = stackOfStrings.topItem {
    print("The top item on the stack is \(topItem).")
}
// "The top item on the stack is tres." 를 출력합니다.
```

제네릭 타입의 '익스텐션' 은 확장된 타입의 인스턴스가 새로운 기능을 획득하기 위해 반드시 만족해야 하는 '필수 조건 (requirements)' 을 포함할 수도 있는데, 이는 아래의 [Extensions with a Generic Where Clause (일반화된 Where 구절을 가지는 확장)](#extensions-with-a-generic-where-clause-제네릭-where-구절을-가지는-익스텐션-일반화된-where-구절을-가지는-확장) 에서 설명합니다.

### Type Constraints (타입 구속 조건)

`swapTwoValues​​(_:_:)` 함수와 `Stack` 타입은 어떤 타입이든 같이 작업할 수 있습니다. 하지만, 제네릭 (일반화된) 함수 및 제네릭 (일반화된) 타입과 같이 사용할 수 있는 타입에 대해 지정된 _타입 구속 조건 (type constraints)_ 을 강제하는 것이 유용할 때가 있습니다. '타입 구속 조건' 은 타입 매개 변수가 반드시 지정된 클래스를 상속받도록 지정하거나, 특정한 프로토콜 또는 특정한 '프로토콜 조합 (protocol composition)'[^protocol-composition] 을 준수하도록 지정합니다.

예를 들어, 스위프트의 `Dictionary` 타입은 딕셔너리의 키로 사용할 수 있는 타입에 대한 제한을 둡니다. [Dictionaries (딕셔너리; 사전)]({% post_url 2016-06-06-Collection-Types %}#dictionaries-딕셔너리-사전) 에서 설명한 것처럼, 딕셔너리의 키 타입은 반드시 '_해시 가능 (hashable)_' 해야 합니다. 즉, 스스로를 유일하게 표현할 수 있는 방법을 반드시 제공해야 합니다. `Dictionary` 의 키가 '해시 가능 (hashable)' 해야 특정한 키에 대한 값을 이미 담고 있는 지 검사할 수 있습니다. 이러한 '필수 조건 (requirement)' 이 없다면, `Dictionary` 는 특정한 키에 대한 값을 집어 넣어야 할지 교체해야 할지 알 수가 없고, 주어진 키에 대한 값이 '딕셔너리' 에 이미 있는지 찾을 수도 없을 것입니다.

이러한 '필수 조건' 은 `Dictionary` 의 키 타입에 있는 '타입 구속 조건 (type constraint)' 에서 강제하며, 여기서 키 타입이, 스위프트 표준 라이브러리에서 정의한 특수한 프로토콜인, `Hashable` 프로토콜을 반드시 준수해야 한다고 지정하게 됩니다. 스위프트의 모든 기본 타입들 (`String`, `Int`, `Double`, 및 `Bool`) 은 기본적으로 '해시 가능 (hashable)' 하다고 설정되어 있습니다. 자신만의 사용자 정의 타입이 `Hashable` 프로토콜을 준수하도록 만드는 것에 대한 정보는, [Conforming to the Hashable Protocol](https://developer.apple.com/documentation/swift/hashable#2849490) 을 참고하기 바랍니다.

사용자 정의 제네릭 타입을 생성할 때 자신만의 타입 구속 조건을 정의할 수 있으며, 이러한 구속 조건이 '제네릭 프로그래밍 (genenric programming)' 이 가진 강력함의 대부분을 제공하는 것입니다. `Hashable` 같은 '추상적인 개념 (abstract concepts)' 은, '구체적인 타입 (concrete type)' 이 아니라, '개념적인 성질 (conceptual characteristics)' 로써 타입의 성질을 규정합니다.

#### Type Constraint Syntax (타입 구속 조건 구문 표현)

#### Type Constraints in Action (타입 구속 조건의 실제 사례)

### Associated Types (결합된 타입)

#### Associated Types in Action (결합된 타입의 실제 사례)

#### Extending an Existing Type to Specify an Associated Type (기존 타입을 확장하여 결합된 타입 지정하기)

#### Adding Constraints to an Associated Type (결합된 타입에 구속 조건 추가하기)

#### Using a Protocol in Its Associated Type's Constaints (프로토콜을 자신의 결합된 타입의 구속 조건에서 사용하기)

### Generic Where Clauses (일반화된 where 구절)

[Type Constraints (타입 구속 조건)](#type-constraints-타입-구속-조건) 에서 설명한 대로, '타입 구속 조건'을 사용하면 일반화된 함수, 일반화된 첨자 연산자 또는 일반화된 타입들과 결합되어 있는 타입 매개 변수들에 대한 '필수 조건' 을 정의할 수 있습니다.

여기에 더해서 '결합된 타입 (associated type)' 에 대한 '필수 조건' 을 정의할 때도 유용하게 쓸 수 있는데, 이 때는 _일반화된 where 구절_ 을 정의하면 됩니다. 일반화된 `where` 구절을 사용하면 '결합된 타입'이 반드시 특정 프로토콜을 준수해야 한다거나, 특정 '타입 매개 변수'와 '결합된 타입'이 같아야 한다는 요구 사항들을 덧붙일 수 있습니다. 일반화된 `where` 구절은 `where` 키워드로 시작해서, 뒤이어서 '결합된 타입' 에 대한 '구속 조건' 또는 타입과 '결합된 타입' 간의 '동등 관계' 등이 따라옵니다. 일반화된 `where` 구절은 타입이나 함수 본문의 시작 괄호 바로 앞에 작성합니다.

아래 예제는 일반화된 함수인 `allItemsMatch` 를 정의하는데, 이 함수는 두 개의 `Container` 인스턴스가 동일한 요소를 동일한 순서로 갖고 있는지를 검사합니다. 이 함수는 불 (Boolean) 값을 반환하며 모든 요소가 일치하면 `true` 를 그렇지 않으면 `false` 를 반환합니다.

두 컨테이너를 검사할 때 컨테이너의 타입이 같을 필요는 없지만 (물론 같더라도 상관없습니다), 각 요소들의 타입은 같아야 합니다. 이 요구 사항은 '타입 구속 조건 (type constraints)' 과 '일반화된 where 구절' 을 조합하여 표현합니다.

```swift
func allItemsMatch<C1: Container, C2: Container>(_ someContainer: C1, _ anotherContainer: C2) -> Bool where C1.Item == C2.Item, C1.Item: Equatable {
  // Check that both containers contain the same number of items.
  if someContainer.count != anotherContainer.count {
    return false
  }

  // Check each pair of items to see if they're equivalent.
  for i in 0..<someContainer.count {
    if someContainer[i] != anotherContainer[i] {
      return false
    }
  }

  // All items match, so return true.
  return true
}
```

이 함수는 두 인자로 `someContainer` 와 `anotherContainer` 를 사용합니다. `someContainer` 인자는 `C1` 타입이고, `anotherContainer` 인자는 `C2` 타입입니다. `C1` 과 `C2` 는 두 개의 컨테이터 타입을 위한 '타입 매개 변수' 로써 함수가 호출될 때 결정됩니다.

이 함수의 두 '타입 매개 변수'는 아래의 요구 사항들을 갖습니다:

* `C1` 은 반드시 `Container` 프로토콜을 준수해야 합니다. (`C1: Container` 로 적혀 있습니다.)
* `C2` 도 반드시 `Container` 프로토콜을 준수해야 합니다. (`C2: Container` 로 적혀 있습니다.)
* `C1` 의 요소는 `C2` 의 요소와 반드시 동일해야 합니다. (`C1.Item == C2.Item` 로 적혀 있습니다.)[^Items]
* `C1` 의 요소는 반드시 `Equatable` 프로토콜을 준수해야 합니다. (`C1.Item : Equatable` 로 적혀 있습니다.)

첫 번째와 두 번째 요구 사항은 함수의 '타입 매개 변수 목록 (type parameter list)' 에 정의되어 있고, 세 번째와 네 번째 요구 사항은 '일반화된 where 구절' 에 정의되어 있습니다.

이 요구 사항들이 의미하는 것은 다음과 같습니다:

* `someContainer` 는 `C1` 타입의 컨테이너 입니다.
* `anotherContainer` 는 `C2` 타입의 컨테이너 입니다.
* `someContainer` 와 `anotherContainer` 는 같은 타입의 요소를 가집니다.
* `someContainer` 의 요소들은 '같지 않음 연산자 (!=)' 로 서로 다른지를 확인할 수 있어야 합니다.

세 번째와 네 번째 요구 사항을 조합하면 `anotherContainer` 의 요소들도 '같지 않음 연산자 (!=)' 로 검사할 수 있다는 의미가 되는데, 이는 `someContainer` 의 요소와 타입이 똑 같기 때문입니다.

이러한 요구 사항에 덕분에 두 컨테이너의 타입이 달라도 `allItemsMatch(_:_:)` 함수로 비교할 수 있게 되는 것입니다.

`allItemsMatch(_:_:)` 함수는 먼저 두 컨테이너의 요소 개수가 같은지를 검사합니다. 요소의 개수가 다르다면, 서로 같을 수가 없으므로, 함수의 반환 값은 `false` 입니다.

이 검사를 마친 후, `someContainer` 의 모든 요소들에 반복해서 적용할 방법으로 `for-in` 루프와 '반-개방 범위 연산자 (`..<`)'를 사용합니다. 각 요소 마다, `someContainer` 의 요소와 `anotherContainer` 의 요소가 다른지를 검사합니다. 두 요소가 다르다면, 두 컨테이너가 같을 수 없으므로, 함수의 반환 값은 `false` 입니다.

아무런 문제없이 루프를 완료하면, 두 컨테이너가 같은 것이므로, 함수의 반환 값은 `true` 입니다.

`allItemsMatch(_:_:)` 함수의 사용법은 다음과 같습니다:


```swift
var stackOfStrings = Stack<String>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
  print("All items match.")
} else {
  print("Not all items match.")
}

// Prints "All items match."
```

위 예제는 `String` (문자열) 값을 저장하기 위해 `Stack` (스택) 인스턴스를 만들고, 3 개의 문자열을 스택에 집어 넣습니다. 또 `Array` (배열) 인스턴스를 만든 다음 '배열 문자식 (array literal)' 으로 초기화할 때 스택에 넣었던 것과 동일한 3 개의 문자열을 사용합니다. 스택과 배열은 다른 타입이지만, 둘 다 `Container` 프로토콜을 준수하며, 같은 타입의 값을 갖고 있습니다. 따라서 `allItemsMatch(_:_:)` 함수를 호출하면서 이 두 컨테이너를 인자로 넣을 수 있습니다. 위에서 `allItemsMatch(_:_:)` 함수가 두 컨테이터의 모든 요소 값들을 제대로 비교하고 있음을 확인할 수 있습니다.

### Extensions with a Generic Where Clause (일반화된 Where 구절을 가지는 확장)

### Contextual Where Clauses

### Associated Types with a Generic Where Clause

### Generic Subscripts

### 참고 자료

[^Generics]: 원문은 [Generics](https://docs.swift.org/swift-book/LanguageGuide/Generics.html)에서 확인할 수 있습니다.

[^language-guide]: 'Language Guide (언어 설명서)' 는 'Swift Programming Language' 책에서 스위프트의 문법을 설명하는 부분으로, 지금 보고 있는 글들이 이 'Language Guide' 에 속해 있는 것들입니다.

[^LIFO]: '후입 선출법 (last in, first out)' 이라는 용어에 대해서는 위키피디아의 [FIFO and LIFO accounting](https://en.wikipedia.org/wiki/FIFO_and_LIFO_accounting) 와 [선입 선출법과 후입 선출법](https://ko.wikipedia.org/wiki/선입_선출법과_후입_선출법) 항목을 참고하기 바랍니다. 이 용어는 컴퓨터 이전부터 사용되었던 것 같습니다. 컴퓨터 용어로 'LIFO' 를 검색하면 '스택 (stack)' 으로 연결되는데 이는 위키피디아의 [Stack (abstract data type)](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) 과 [스택](https://ko.wikipedia.org/wiki/스택) 항목을 참고하기 바랍니다.

[^extension]: 여기서의 'extension' 은 스위프트에 있는 키워드 자체를 나타내는데 사용되었기 때문에 '익스텐션' 이라고 발음 그대로 옮깁니다. 'extension' 자체가 '확장' 이라는 의미를 가지고 있습니다.

[^protocol-composition]: '프로토콜 조합 (protocol composition)' 에 대해서는 [Protocol Composition (프로토콜 조합)]({% post_url 2016-03-03-Protocols %}#protocol-composition-프로토콜-조합) 부분을 참고하기 바랍니다.

[^Items]: 이 조건을 만족하면 요소의 값뿐만 아니라, 각 요소들의 타입이 같다는 것도 보장됩니다. 각 요소가 같음을 비교하려면 각 요소의 타입이 같아야 하기 때문입니다.
